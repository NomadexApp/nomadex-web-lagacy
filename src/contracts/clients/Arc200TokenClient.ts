/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication(address)void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "updateApplication()void": {
      "call_config": {
        "update_application": "CALL"
      }
    },
    "setManager(address)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "initialize(byte[32],byte[8],uint8,uint256,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_name()byte[32]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_symbol()byte[8]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_decimals()uint8": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_totalSupply()uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_balanceOf(address)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "hasBalance(address)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "hasAllowance(address,address)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_allowance(address,address)uint256": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_transfer(address,uint256)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_approve(address,uint256)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc200_transferFrom(address,address,uint256)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "deleteApplication()void": {
      "call_config": {
        "delete_application": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "manager": {
          "type": "bytes",
          "key": "manager"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 1,
      "num_uints": 0
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjgwLjEKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbG1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICJOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggY2FsbF9Ob09wIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIGNhbGxfVXBkYXRlQXBwbGljYXRpb24gY2FsbF9EZWxldGVBcHBsaWNhdGlvbiBjcmVhdGVfTm9PcCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVECgpOT1RfSU1QTEVNRU5URUQ6CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKGFkZHJlc3Mpdm9pZAphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBtYW5hZ2VyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbihhZGRyZXNzKXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKG1hbmFnZXI6IEFkZHJlc3MpOiB2b2lkCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMSAwCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjE3CgkvLyB0aGlzLm1hbmFnZXIudmFsdWUgPSBtYW5hZ2VyCglieXRlIDB4NmQ2MTZlNjE2NzY1NzIgLy8gIm1hbmFnZXIiCglmcmFtZV9kaWcgLTEgLy8gbWFuYWdlcjogQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gdXBkYXRlQXBwbGljYXRpb24oKXZvaWQKYWJpX3JvdXRlX3VwZGF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSB1cGRhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiB1cGRhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gdXBkYXRlQXBwbGljYXRpb24oKTogdm9pZAp1cGRhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyMQoJLy8gYXNzZXJ0KHRoaXMubWFuYWdlci52YWx1ZSA9PT0gdGhpcy50eG4uc2VuZGVyKQoJYnl0ZSAweDZkNjE2ZTYxNjc2NTcyIC8vICJtYW5hZ2VyIgoJYXBwX2dsb2JhbF9nZXQKCXR4biBTZW5kZXIKCT09Cglhc3NlcnQKCXJldHN1YgoKLy8gc2V0TWFuYWdlcihhZGRyZXNzKWJvb2wKYWJpX3JvdXRlX3NldE1hbmFnZXI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIG1hbmFnZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIHNldE1hbmFnZXIoYWRkcmVzcylib29sCgljYWxsc3ViIHNldE1hbmFnZXIKCWJ5dGUgMHgwMAoJaW50IDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gc2V0TWFuYWdlcihtYW5hZ2VyOiBBZGRyZXNzKTogYm9vbGVhbgpzZXRNYW5hZ2VyOgoJcHJvdG8gMSAxCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI1CgkvLyBhc3NlcnQodGhpcy5tYW5hZ2VyLnZhbHVlID09PSB0aGlzLnR4bi5zZW5kZXIpCglieXRlIDB4NmQ2MTZlNjE2NzY1NzIgLy8gIm1hbmFnZXIiCglhcHBfZ2xvYmFsX2dldAoJdHhuIFNlbmRlcgoJPT0KCWFzc2VydAoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNgoJLy8gdGhpcy5tYW5hZ2VyLnZhbHVlID0gbWFuYWdlcgoJYnl0ZSAweDZkNjE2ZTYxNjc2NTcyIC8vICJtYW5hZ2VyIgoJZnJhbWVfZGlnIC0xIC8vIG1hbmFnZXI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI3CgkvLyByZXR1cm4gdHJ1ZTsKCWludCAxCglyZXRzdWIKCi8vIGFyYzIwMEluaXRpYWxpemUobmFtZTogU3RhdGljQXJyYXk8Ynl0ZSwgMzI+LCBzeW1ib2w6IFN0YXRpY0FycmF5PGJ5dGUsIDg+LCBkZWNpbWFsczogdWludDgsIHRvdGFsU3VwcGx5OiB1aW50MjU2LCBtaW50VG86IEFkZHJlc3MpOiB2b2lkCmFyYzIwMEluaXRpYWxpemU6Cglwcm90byA1IDAKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MzcKCS8vIHRoaXMubWV0YWRhdGEudmFsdWUgPSB7CgkvLyAJCQluYW1lOiBuYW1lLAoJLy8gCQkJc3ltYm9sOiBzeW1ib2wsCgkvLyAJCQlkZWNpbWFsczogZGVjaW1hbHMsCgkvLyAJCX0KCWJ5dGUgMHg2ZDY1NzQ2MTY0NjE3NDYxIC8vICJtZXRhZGF0YSIKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBTdGF0aWNBcnJheTxieXRlLCAzMj4KCWZyYW1lX2RpZyAtMiAvLyBzeW1ib2w6IFN0YXRpY0FycmF5PGJ5dGUsIDg+Cgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyBkZWNpbWFsczogdWludDgKCWl0b2IKCWV4dHJhY3QgNyAxCgljb25jYXQKCWJveF9wdXQKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6NDIKCS8vIHRoaXMudG90YWxTdXBwbHkudmFsdWUgPSB0b3RhbFN1cHBseQoJYnl0ZSAweDc0NmY3NDYxNmM1Mzc1NzA3MDZjNzkgLy8gInRvdGFsU3VwcGx5IgoJZnJhbWVfZGlnIC00IC8vIHRvdGFsU3VwcGx5OiB1aW50MjU2Cglib3hfcHV0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjQ0CgkvLyB0aGlzLmJhbGFuY2VzKG1pbnRUbykudmFsdWUgPSB0b3RhbFN1cHBseQoJZnJhbWVfZGlnIC01IC8vIG1pbnRUbzogQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIHRvdGFsU3VwcGx5OiB1aW50MjU2Cglib3hfcHV0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjQ2CgkvLyB0aGlzLmFyYzIwMF9UcmFuc2Zlci5sb2coewoJLy8gCQkJZnJvbTogZ2xvYmFscy56ZXJvQWRkcmVzcywKCS8vIAkJCXRvOiBtaW50VG8sCgkvLyAJCQl2YWx1ZTogdG90YWxTdXBwbHksCgkvLyAJCX0pCglieXRlIDB4Nzk4M2MzNWMgLy8gYXJjMjAwX1RyYW5zZmVyKGFkZHJlc3MsYWRkcmVzcyx1aW50MjU2KQoJZ2xvYmFsIFplcm9BZGRyZXNzCglmcmFtZV9kaWcgLTUgLy8gbWludFRvOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2RpZyAtNCAvLyB0b3RhbFN1cHBseTogdWludDI1NgoJY29uY2F0Cgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBpbml0aWFsaXplKGJ5dGVbMzJdLGJ5dGVbOF0sdWludDgsdWludDI1NixhZGRyZXNzKXZvaWQKYWJpX3JvdXRlX2luaXRpYWxpemU6CgkvLyBtaW50VG86IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyB0b3RhbFN1cHBseTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGRlY2ltYWxzOiB1aW50OAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAxCgk9PQoJYXNzZXJ0CglidG9pCgoJLy8gc3ltYm9sOiBieXRlWzhdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDgKCT09Cglhc3NlcnQKCgkvLyBuYW1lOiBieXRlWzMyXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgaW5pdGlhbGl6ZShieXRlWzMyXSxieXRlWzhdLHVpbnQ4LHVpbnQyNTYsYWRkcmVzcyl2b2lkCgljYWxsc3ViIGluaXRpYWxpemUKCWludCAxCglyZXR1cm4KCi8vIGluaXRpYWxpemUobmFtZTogU3RhdGljQXJyYXk8Ynl0ZSwgMzI+LCBzeW1ib2w6IFN0YXRpY0FycmF5PGJ5dGUsIDg+LCBkZWNpbWFsczogdWludDgsIHRvdGFsU3VwcGx5OiB1aW50MjU2LCBtaW50VG86IEFkZHJlc3MpOiB2b2lkCi8vCi8vIEluaXRpYWxpemUgQVJDMjAwCi8vIEBwYXJhbSBuYW1lIHRva2VuIG5hbWUKLy8gQHBhcmFtIHN5bWJvbCB0b2tlbiBzeW1ib2wKLy8gQHBhcmFtIGRlY2ltYWxzIG51bWJlciBvZiBkZWNpbWFscwovLyBAcGFyYW0gdG90YWxTdXBwbHkgdG90YWwgc3VwcGx5IG9mIHRva2VucwovLyBAcGFyYW0gbWludFRvIGluaXRpYWwgbWludCB0bwppbml0aWFsaXplOgoJcHJvdG8gNSAwCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjY4CgkvLyBhc3NlcnQodGhpcy5hcHAuY3JlYXRvciA9PT0gdGhpcy50eG4uc2VuZGVyIHx8IHRoaXMubWFuYWdlci52YWx1ZSA9PT0gdGhpcy50eG4uc2VuZGVyKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgl0eG4gU2VuZGVyCgk9PQoJZHVwCglibnogc2tpcF9vcjAKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWFwcF9nbG9iYWxfZ2V0Cgl0eG4gU2VuZGVyCgk9PQoJfHwKCnNraXBfb3IwOgoJYXNzZXJ0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjY5CgkvLyBhc3NlcnQoIXRoaXMudG90YWxTdXBwbHkuZXhpc3RzKQoJYnl0ZSAweDc0NmY3NDYxNmM1Mzc1NzA3MDZjNzkgLy8gInRvdGFsU3VwcGx5IgoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6NzEKCS8vIHRoaXMuYXJjMjAwSW5pdGlhbGl6ZShuYW1lLCBzeW1ib2wsIGRlY2ltYWxzLCB0b3RhbFN1cHBseSwgbWludFRvKQoJZnJhbWVfZGlnIC01IC8vIG1pbnRUbzogQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIHRvdGFsU3VwcGx5OiB1aW50MjU2CglmcmFtZV9kaWcgLTMgLy8gZGVjaW1hbHM6IHVpbnQ4CglmcmFtZV9kaWcgLTIgLy8gc3ltYm9sOiBTdGF0aWNBcnJheTxieXRlLCA4PgoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IFN0YXRpY0FycmF5PGJ5dGUsIDMyPgoJY2FsbHN1YiBhcmMyMDBJbml0aWFsaXplCglyZXRzdWIKCi8vIGFyYzIwMF9uYW1lKClieXRlWzMyXQphYmlfcm91dGVfYXJjMjAwX25hbWU6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgYXJjMjAwX25hbWUoKWJ5dGVbMzJdCgljYWxsc3ViIGFyYzIwMF9uYW1lCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYXJjMjAwX25hbWUoKTogU3RhdGljQXJyYXk8Ynl0ZSwgMzI+Ci8vCi8vIFRoZSBuYW1lIG9mIHRoZSB0b2tlbgovLyBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgdG9rZW4KYXJjMjAwX25hbWU6Cglwcm90byAwIDEKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6ODAKCS8vIHJldHVybiB0aGlzLm1ldGFkYXRhLnZhbHVlLm5hbWU7CglieXRlIDB4NmQ2NTc0NjE2NDYxNzQ2MSAvLyAibWV0YWRhdGEiCglpbnQgMAoJaW50IDMyCglib3hfZXh0cmFjdAoJcmV0c3ViCgovLyBhcmMyMDBfc3ltYm9sKClieXRlWzhdCmFiaV9yb3V0ZV9hcmMyMDBfc3ltYm9sOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGFyYzIwMF9zeW1ib2woKWJ5dGVbOF0KCWNhbGxzdWIgYXJjMjAwX3N5bWJvbAoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFyYzIwMF9zeW1ib2woKTogU3RhdGljQXJyYXk8Ynl0ZSwgOD4KLy8KLy8gUmV0dXJucyB0aGUgc3ltYm9sIG9mIHRoZSB0b2tlbgovLyBAcmV0dXJucyBUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbgphcmMyMDBfc3ltYm9sOgoJcHJvdG8gMCAxCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjg5CgkvLyByZXR1cm4gdGhpcy5tZXRhZGF0YS52YWx1ZS5zeW1ib2w7CglieXRlIDB4NmQ2NTc0NjE2NDYxNzQ2MSAvLyAibWV0YWRhdGEiCglpbnQgMzIgLy8gaGVhZE9mZnNldAoJaW50IDgKCWJveF9leHRyYWN0CglyZXRzdWIKCi8vIGFyYzIwMF9kZWNpbWFscygpdWludDgKYWJpX3JvdXRlX2FyYzIwMF9kZWNpbWFsczoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBhcmMyMDBfZGVjaW1hbHMoKXVpbnQ4CgljYWxsc3ViIGFyYzIwMF9kZWNpbWFscwoJaXRvYgoJZHVwCgliaXRsZW4KCWludCA4Cgk8PQoJYXNzZXJ0CglleHRyYWN0IDcgMQoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFyYzIwMF9kZWNpbWFscygpOiB1aW50OAovLwovLyBSZXR1cm5zIHRoZSBkZWNpbWFscyBvZiB0aGUgdG9rZW4KLy8gQHJldHVybnMgVGhlIGRlY2ltYWxzIG9mIHRoZSB0b2tlbgphcmMyMDBfZGVjaW1hbHM6Cglwcm90byAwIDEKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6OTgKCS8vIHJldHVybiB0aGlzLm1ldGFkYXRhLnZhbHVlLmRlY2ltYWxzOwoJYnl0ZSAweDZkNjU3NDYxNjQ2MTc0NjEgLy8gIm1ldGFkYXRhIgoJaW50IDQwIC8vIGhlYWRPZmZzZXQKCWludCAxCglib3hfZXh0cmFjdAoJYnRvaQoJcmV0c3ViCgovLyBhcmMyMDBfdG90YWxTdXBwbHkoKXVpbnQyNTYKYWJpX3JvdXRlX2FyYzIwMF90b3RhbFN1cHBseToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBhcmMyMDBfdG90YWxTdXBwbHkoKXVpbnQyNTYKCWNhbGxzdWIgYXJjMjAwX3RvdGFsU3VwcGx5CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhcmMyMDBfdG90YWxTdXBwbHkoKTogdWludDI1NgovLwovLyBSZXR1cm5zIHRoZSB0b3RhbCBzdXBwbHkgb2YgdGhlIHRva2VuCi8vIEByZXR1cm5zIFRoZSB0b3RhbCBzdXBwbHkgb2YgdGhlIHRva2VuCmFyYzIwMF90b3RhbFN1cHBseToKCXByb3RvIDAgMQoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoxMDcKCS8vIHJldHVybiAoCgkvLyAJCQl0aGlzLnRvdGFsU3VwcGx5LnZhbHVlIC0gdGhpcy5hcmMyMDBfYmFsYW5jZU9mKGdsb2JhbHMuemVyb0FkZHJlc3MpIC0gdGhpcy5hcmMyMDBfYmFsYW5jZU9mKHRoaXMuYXBwLmFkZHJlc3MpCgkvLyAJCSk7CglieXRlIDB4NzQ2Zjc0NjE2YzUzNzU3MDcwNmM3OSAvLyAidG90YWxTdXBwbHkiCglib3hfZ2V0Cglhc3NlcnQKCWdsb2JhbCBaZXJvQWRkcmVzcwoJY2FsbHN1YiBhcmMyMDBfYmFsYW5jZU9mCgliLQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWNhbGxzdWIgYXJjMjAwX2JhbGFuY2VPZgoJYi0KCXJldHN1YgoKLy8gYXJjMjAwX2JhbGFuY2VPZihhZGRyZXNzKXVpbnQyNTYKYWJpX3JvdXRlX2FyYzIwMF9iYWxhbmNlT2Y6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIG93bmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhcmMyMDBfYmFsYW5jZU9mKGFkZHJlc3MpdWludDI1NgoJY2FsbHN1YiBhcmMyMDBfYmFsYW5jZU9mCglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhcmMyMDBfYmFsYW5jZU9mKG93bmVyOiBBZGRyZXNzKTogdWludDI1NgovLwovLyBSZXR1cm5zIHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgdGhlIG93bmVyIG9mIHRoZSB0b2tlbgovLyBAcGFyYW0gb3duZXIgVGhlIGFkZHJlc3Mgb2YgdGhlIG93bmVyIG9mIHRoZSB0b2tlbgovLyBAcmV0dXJucyBUaGUgY3VycmVudCBiYWxhbmNlIG9mIHRoZSBob2xkZXIgb2YgdGhlIHRva2VuCmFyYzIwMF9iYWxhbmNlT2Y6Cglwcm90byAxIDEKCgkvLyBpZjBfY29uZGl0aW9uCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MTE5CgkvLyB0aGlzLmJhbGFuY2VzKG93bmVyKS5leGlzdHMKCWZyYW1lX2RpZyAtMSAvLyBvd25lcjogQWRkcmVzcwoJYm94X2xlbgoJc3dhcAoJcG9wCglieiBpZjBfZWxzZQoKCS8vIGlmMF9jb25zZXF1ZW50CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MTIwCgkvLyByZXR1cm4gdGhpcy5iYWxhbmNlcyhvd25lcikudmFsdWU7CglmcmFtZV9kaWcgLTEgLy8gb3duZXI6IEFkZHJlc3MKCWJveF9nZXQKCWFzc2VydAoJcmV0c3ViCgliIGlmMF9lbmQKCmlmMF9lbHNlOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjEyMgoJLy8gcmV0dXJuIDx1aW50MjU2PjA7CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJcmV0c3ViCgppZjBfZW5kOgoJcmV0c3ViCgovLyBoYXNCYWxhbmNlKGFkZHJlc3MpYm9vbAphYmlfcm91dGVfaGFzQmFsYW5jZToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gb3duZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGhhc0JhbGFuY2UoYWRkcmVzcylib29sCgljYWxsc3ViIGhhc0JhbGFuY2UKCWJ5dGUgMHgwMAoJaW50IDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gaGFzQmFsYW5jZShvd25lcjogQWRkcmVzcyk6IGJvb2xlYW4KLy8KLy8gQ2hlY2sgaWYgYmFsYW5jZSBib3ggZXhpc3RzCi8vIEBwYXJhbSBvd25lciBUaGUgYWRkcmVzcyBvZiB0aGUgb3duZXIKLy8gQHJldHVybnMgYHRydWVgIGlmIGJhbGFuY2UgYm94IGV4aXN0cwpoYXNCYWxhbmNlOgoJcHJvdG8gMSAxCgoJLy8gaWYxX2NvbmRpdGlvbgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjEzMwoJLy8gdGhpcy5iYWxhbmNlcyhvd25lcikuZXhpc3RzCglmcmFtZV9kaWcgLTEgLy8gb3duZXI6IEFkZHJlc3MKCWJveF9sZW4KCXN3YXAKCXBvcAoJYnogaWYxX2VuZAoKCS8vIGlmMV9jb25zZXF1ZW50CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MTM0CgkvLyByZXR1cm4gdHJ1ZTsKCWludCAxCglyZXRzdWIKCmlmMV9lbmQ6CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MTM2CgkvLyByZXR1cm4gZmFsc2U7CglpbnQgMAoJcmV0c3ViCgovLyBoYXNBbGxvd2FuY2UoYWRkcmVzcyxhZGRyZXNzKWJvb2wKYWJpX3JvdXRlX2hhc0FsbG93YW5jZToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gc3BlbmRlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIG93bmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBoYXNBbGxvd2FuY2UoYWRkcmVzcyxhZGRyZXNzKWJvb2wKCWNhbGxzdWIgaGFzQWxsb3dhbmNlCglieXRlIDB4MDAKCWludCAwCgl1bmNvdmVyIDIKCXNldGJpdAoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGhhc0FsbG93YW5jZShvd25lcjogQWRkcmVzcywgc3BlbmRlcjogQWRkcmVzcyk6IGJvb2xlYW4KLy8KLy8gQ2hlY2sgaWYgYWxsb3dhbmNlIGJveCBleGlzdHMKLy8gQHBhcmFtIG93bmVyIFRoZSBhZGRyZXNzIG9mIHRoZSBvd25lcgovLyBAcGFyYW0gc3BlbmRlciBUaGUgYWRkcmVzcyBvZiB0aGUgc3BlbmRlcgovLyBAcmV0dXJucyBgdHJ1ZWAgaWYgYWxsb3dhbmNlIGJveCBleGlzdHMKaGFzQWxsb3dhbmNlOgoJcHJvdG8gMiAxCgoJLy8gaWYyX2NvbmRpdGlvbgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjE0NwoJLy8gdGhpcy5hbGxvd2FuY2VzKFtvd25lciwgc3BlbmRlcl0pLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIG93bmVyOiBBZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gc3BlbmRlcjogQWRkcmVzcwoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCWJ6IGlmMl9lbmQKCgkvLyBpZjJfY29uc2VxdWVudAoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjE0OAoJLy8gcmV0dXJuIHRydWU7CglpbnQgMQoJcmV0c3ViCgppZjJfZW5kOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjE1MAoJLy8gcmV0dXJuIGZhbHNlOwoJaW50IDAKCXJldHN1YgoKLy8gYXJjMjAwX2FsbG93YW5jZShhZGRyZXNzLGFkZHJlc3MpdWludDI1NgphYmlfcm91dGVfYXJjMjAwX2FsbG93YW5jZToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gc3BlbmRlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIG93bmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhcmMyMDBfYWxsb3dhbmNlKGFkZHJlc3MsYWRkcmVzcyl1aW50MjU2CgljYWxsc3ViIGFyYzIwMF9hbGxvd2FuY2UKCWR1cAoJYml0bGVuCglpbnQgMjU2Cgk8PQoJYXNzZXJ0CglieXRlIDB4RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRgoJYiYKCWR1cAoJbGVuCglkdXAKCWludCAzMgoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFyYzIwMF9hbGxvd2FuY2Uob3duZXI6IEFkZHJlc3MsIHNwZW5kZXI6IEFkZHJlc3MpOiB1aW50MjU2Ci8vCi8vIFJldHVybnMgdGhlIGN1cnJlbnQgYWxsb3dhbmNlIG9mIHRoZSBzcGVuZGVyIG9mIHRoZSB0b2tlbnMgb2YgdGhlIG93bmVyCi8vIEBwYXJhbSBvd25lcgovLyBAcGFyYW0gc3BlbmRlcgovLyBAcmV0dXJucyBUaGUgcmVtYWluaW5nIGFsbG93YW5jZQphcmMyMDBfYWxsb3dhbmNlOgoJcHJvdG8gMiAxCgoJLy8gaWYzX2NvbmRpdGlvbgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjE2MQoJLy8gdGhpcy5hbGxvd2FuY2VzKFtvd25lciwgc3BlbmRlcl0pLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIG93bmVyOiBBZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gc3BlbmRlcjogQWRkcmVzcwoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCWJ6IGlmM19lbHNlCgoJLy8gaWYzX2NvbnNlcXVlbnQKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoxNjIKCS8vIHJldHVybiB0aGlzLmFsbG93YW5jZXMoW293bmVyLCBzcGVuZGVyXSkudmFsdWU7CglmcmFtZV9kaWcgLTEgLy8gb3duZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBzcGVuZGVyOiBBZGRyZXNzCgljb25jYXQKCWJveF9nZXQKCWFzc2VydAoJcmV0c3ViCgliIGlmM19lbmQKCmlmM19lbHNlOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjE2NAoJLy8gcmV0dXJuIDx1aW50MjU2PjA7CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJcmV0c3ViCgppZjNfZW5kOgoJcmV0c3ViCgovLyBhcmMyMDBfdHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KWJvb2wKYWJpX3JvdXRlX2FyYzIwMF90cmFuc2ZlcjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gdmFsdWU6IHVpbnQyNTYKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyB0bzogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYXJjMjAwX3RyYW5zZmVyKGFkZHJlc3MsdWludDI1Nilib29sCgljYWxsc3ViIGFyYzIwMF90cmFuc2ZlcgoJYnl0ZSAweDAwCglpbnQgMAoJdW5jb3ZlciAyCglzZXRiaXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhcmMyMDBfdHJhbnNmZXIodG86IEFkZHJlc3MsIHZhbHVlOiB1aW50MjU2KTogYm9vbGVhbgovLwovLyBUcmFuc2ZlcnMgdG9rZW5zCi8vIEBwYXJhbSB0byBUaGUgZGVzdGluYXRpb24gb2YgdGhlIHRyYW5zZmVyCi8vIEBwYXJhbSB2YWx1ZSBBbW91bnQgb2YgdG9rZW5zIHRvIHRyYW5zZmVyCi8vIEByZXR1cm5zIFN1Y2Nlc3MKYXJjMjAwX3RyYW5zZmVyOgoJcHJvdG8gMiAxCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjE5OQoJLy8gcmV0dXJuIHRoaXMudHJhbnNmZXIodGhpcy50eG4uc2VuZGVyLCB0bywgdmFsdWUpOwoJZnJhbWVfZGlnIC0yIC8vIHZhbHVlOiB1aW50MjU2CglmcmFtZV9kaWcgLTEgLy8gdG86IEFkZHJlc3MKCXR4biBTZW5kZXIKCWNhbGxzdWIgdHJhbnNmZXIKCXJldHN1YgoKLy8gdHJhbnNmZXIoZnJvbTogQWRkcmVzcywgdG86IEFkZHJlc3MsIHZhbHVlOiB1aW50MjU2KTogYm9vbGVhbgp0cmFuc2ZlcjoKCXByb3RvIDMgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDIKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjAzCgkvLyBzZW5kZXJCYWxhbmNlID0gdGhpcy5hcmMyMDBfYmFsYW5jZU9mKGZyb20pCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJY2FsbHN1YiBhcmMyMDBfYmFsYW5jZU9mCglmcmFtZV9idXJ5IDAgLy8gc2VuZGVyQmFsYW5jZTogdW5zYWZlIHVpbnQyNTYKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjA0CgkvLyBhc3NlcnQoc2VuZGVyQmFsYW5jZSA+PSB2YWx1ZSkKCWZyYW1lX2RpZyAwIC8vIHNlbmRlckJhbGFuY2U6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWI+PQoJYXNzZXJ0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjIwNgoJLy8gc2VuZGVyQmFsYW5jZUFmdGVyID0gPHVpbnQyNTY+KHNlbmRlckJhbGFuY2UgLSB2YWx1ZSkKCWZyYW1lX2RpZyAwIC8vIHNlbmRlckJhbGFuY2U6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWItCglmcmFtZV9idXJ5IDEgLy8gc2VuZGVyQmFsYW5jZUFmdGVyOiB1bnNhZmUgdWludDI1NgoKCS8vIGlmNF9jb25kaXRpb24KCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyMDcKCS8vIHNlbmRlckJhbGFuY2VBZnRlciA+IDx1aW50MjU2PjAKCWZyYW1lX2RpZyAxIC8vIHNlbmRlckJhbGFuY2VBZnRlcjogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgliPgoJYnogaWY0X2Vsc2VpZjFfY29uZGl0aW9uCgoJLy8gaWY0X2NvbnNlcXVlbnQKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyMDgKCS8vIHRoaXMuYmFsYW5jZXMoZnJvbSkudmFsdWUgPSBzZW5kZXJCYWxhbmNlQWZ0ZXIKCWZyYW1lX2RpZyAtMSAvLyBmcm9tOiBBZGRyZXNzCglmcmFtZV9kaWcgMSAvLyBzZW5kZXJCYWxhbmNlQWZ0ZXI6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJveF9wdXQKCWIgaWY0X2VuZAoKaWY0X2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjIwOQoJLy8gdGhpcy5iYWxhbmNlcyhmcm9tKS5leGlzdHMKCWZyYW1lX2RpZyAtMSAvLyBmcm9tOiBBZGRyZXNzCglib3hfbGVuCglzd2FwCglwb3AKCWJ6IGlmNF9lbmQKCgkvLyBpZjRfZWxzZWlmMV9jb25zZXF1ZW50CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjExCgkvLyB0aGlzLmJhbGFuY2VzKGZyb20pLmRlbGV0ZSgpCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJYm94X2RlbAoKaWY0X2VuZDoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyMTQKCS8vIHJlY2VpdmVyQmFsYW5jZUFmdGVyID0gPHVpbnQyNTY+KHRoaXMuYXJjMjAwX2JhbGFuY2VPZih0bykgKyB2YWx1ZSkKCWZyYW1lX2RpZyAtMiAvLyB0bzogQWRkcmVzcwoJY2FsbHN1YiBhcmMyMDBfYmFsYW5jZU9mCglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWIrCglmcmFtZV9idXJ5IDIgLy8gcmVjZWl2ZXJCYWxhbmNlQWZ0ZXI6IHVuc2FmZSB1aW50MjU2CgoJLy8gaWY1X2NvbmRpdGlvbgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjIxNQoJLy8gcmVjZWl2ZXJCYWxhbmNlQWZ0ZXIgPiA8dWludDI1Nj4wCglmcmFtZV9kaWcgMiAvLyByZWNlaXZlckJhbGFuY2VBZnRlcjogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgliPgoJYnogaWY1X2VuZAoKCS8vIGlmNV9jb25zZXF1ZW50CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjE2CgkvLyB0aGlzLmJhbGFuY2VzKHRvKS52YWx1ZSA9IHJlY2VpdmVyQmFsYW5jZUFmdGVyCglmcmFtZV9kaWcgLTIgLy8gdG86IEFkZHJlc3MKCWZyYW1lX2RpZyAyIC8vIHJlY2VpdmVyQmFsYW5jZUFmdGVyOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglib3hfcHV0CgppZjVfZW5kOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjIxOQoJLy8gdGhpcy5hcmMyMDBfVHJhbnNmZXIubG9nKHsKCS8vIAkJCWZyb206IGZyb20sCgkvLyAJCQl0bzogdG8sCgkvLyAJCQl2YWx1ZTogdmFsdWUsCgkvLyAJCX0pCglieXRlIDB4Nzk4M2MzNWMgLy8gYXJjMjAwX1RyYW5zZmVyKGFkZHJlc3MsYWRkcmVzcyx1aW50MjU2KQoJZnJhbWVfZGlnIC0xIC8vIGZyb206IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyB0bzogQWRkcmVzcwoJY29uY2F0CglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWNvbmNhdAoJY29uY2F0Cglsb2cKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjI1CgkvLyByZXR1cm4gdHJ1ZTsKCWludCAxCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMgoJcmV0c3ViCgovLyBhcmMyMDBfYXBwcm92ZShhZGRyZXNzLHVpbnQyNTYpYm9vbAphYmlfcm91dGVfYXJjMjAwX2FwcHJvdmU6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIHZhbHVlOiB1aW50MjU2Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gc3BlbmRlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYXJjMjAwX2FwcHJvdmUoYWRkcmVzcyx1aW50MjU2KWJvb2wKCWNhbGxzdWIgYXJjMjAwX2FwcHJvdmUKCWJ5dGUgMHgwMAoJaW50IDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYXJjMjAwX2FwcHJvdmUoc3BlbmRlcjogQWRkcmVzcywgdmFsdWU6IHVpbnQyNTYpOiBib29sZWFuCi8vCi8vIEFwcHJvdmUgc3BlbmRlciBmb3IgYSB0b2tlbgovLyBAcGFyYW0gc3BlbmRlcgovLyBAcGFyYW0gdmFsdWUKLy8gQHJldHVybnMgU3VjY2VzcwphcmMyMDBfYXBwcm92ZToKCXByb3RvIDIgMQoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyMzUKCS8vIHJldHVybiB0aGlzLmFwcHJvdmUodGhpcy50eG4uc2VuZGVyLCBzcGVuZGVyLCB2YWx1ZSk7CglmcmFtZV9kaWcgLTIgLy8gdmFsdWU6IHVpbnQyNTYKCWZyYW1lX2RpZyAtMSAvLyBzcGVuZGVyOiBBZGRyZXNzCgl0eG4gU2VuZGVyCgljYWxsc3ViIGFwcHJvdmUKCXJldHN1YgoKLy8gYXBwcm92ZShvd25lcjogQWRkcmVzcywgc3BlbmRlcjogQWRkcmVzcywgdmFsdWU6IHVpbnQyNTYpOiBib29sZWFuCmFwcHJvdmU6Cglwcm90byAzIDEKCgkvLyBpZjZfY29uZGl0aW9uCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjM5CgkvLyB2YWx1ZSA+IDx1aW50MjU2PjAKCWZyYW1lX2RpZyAtMyAvLyB2YWx1ZTogdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWI+CglieiBpZjZfZWxzZWlmMV9jb25kaXRpb24KCgkvLyBpZjZfY29uc2VxdWVudAoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI0MAoJLy8gdGhpcy5hbGxvd2FuY2VzKFtvd25lciwgc3BlbmRlcl0pLnZhbHVlID0gdmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBvd25lcjogQWRkcmVzcwoJZnJhbWVfZGlnIC0yIC8vIHNwZW5kZXI6IEFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIHZhbHVlOiB1aW50MjU2Cglib3hfcHV0CgliIGlmNl9lbmQKCmlmNl9lbHNlaWYxX2NvbmRpdGlvbjoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNDEKCS8vIHRoaXMuYWxsb3dhbmNlcyhbb3duZXIsIHNwZW5kZXJdKS5leGlzdHMKCWZyYW1lX2RpZyAtMSAvLyBvd25lcjogQWRkcmVzcwoJZnJhbWVfZGlnIC0yIC8vIHNwZW5kZXI6IEFkZHJlc3MKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglieiBpZjZfZW5kCgoJLy8gaWY2X2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI0MgoJLy8gdGhpcy5hbGxvd2FuY2VzKFtvd25lciwgc3BlbmRlcl0pLmRlbGV0ZSgpCglmcmFtZV9kaWcgLTEgLy8gb3duZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBzcGVuZGVyOiBBZGRyZXNzCgljb25jYXQKCWJveF9kZWwKCmlmNl9lbmQ6CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjQ1CgkvLyB0aGlzLmFyYzIwMF9BcHByb3ZhbC5sb2coewoJLy8gCQkJb3duZXI6IG93bmVyLAoJLy8gCQkJc3BlbmRlcjogc3BlbmRlciwKCS8vIAkJCXZhbHVlOiB2YWx1ZSwKCS8vIAkJfSkKCWJ5dGUgMHgxOTY5Zjg2NSAvLyBhcmMyMDBfQXBwcm92YWwoYWRkcmVzcyxhZGRyZXNzLHVpbnQyNTYpCglmcmFtZV9kaWcgLTEgLy8gb3duZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBzcGVuZGVyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyB2YWx1ZTogdWludDI1NgoJY29uY2F0Cgljb25jYXQKCWxvZwoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNTEKCS8vIHJldHVybiB0cnVlOwoJaW50IDEKCXJldHN1YgoKLy8gYXJjMjAwX3RyYW5zZmVyRnJvbShhZGRyZXNzLGFkZHJlc3MsdWludDI1Nilib29sCmFiaV9yb3V0ZV9hcmMyMDBfdHJhbnNmZXJGcm9tOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyB2YWx1ZTogdWludDI1NgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHRvOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZnJvbTogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYXJjMjAwX3RyYW5zZmVyRnJvbShhZGRyZXNzLGFkZHJlc3MsdWludDI1Nilib29sCgljYWxsc3ViIGFyYzIwMF90cmFuc2ZlckZyb20KCWJ5dGUgMHgwMAoJaW50IDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYXJjMjAwX3RyYW5zZmVyRnJvbShmcm9tOiBBZGRyZXNzLCB0bzogQWRkcmVzcywgdmFsdWU6IHVpbnQyNTYpOiBib29sZWFuCi8vCi8vIFRyYW5zZmVycyB0b2tlbnMgZnJvbSBzb3VyY2UgdG8gZGVzdGluYXRpb24gYXMgYXBwcm92ZWQgc3BlbmRlcgovLyBAcGFyYW0gZnJvbSBUaGUgc291cmNlICBvZiB0aGUgdHJhbnNmZXIKLy8gQHBhcmFtIHRvIFRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgdHJhbnNmZXIKLy8gQHBhcmFtIHZhbHVlIEFtb3VudCBvZiB0b2tlbnMgdG8gdHJhbnNmZXIKLy8gQHJldHVybnMgU3VjY2VzcwphcmMyMDBfdHJhbnNmZXJGcm9tOgoJcHJvdG8gMyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNAoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNjIKCS8vIGFsbG93YW5jZSA9IHRoaXMuYXJjMjAwX2FsbG93YW5jZShmcm9tLCB0aGlzLnR4bi5zZW5kZXIpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJY2FsbHN1YiBhcmMyMDBfYWxsb3dhbmNlCglmcmFtZV9idXJ5IDAgLy8gYWxsb3dhbmNlOiB1bnNhZmUgdWludDI1NgoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNjMKCS8vIGFzc2VydChhbGxvd2FuY2UgPj0gdmFsdWUpCglmcmFtZV9kaWcgMCAvLyBhbGxvd2FuY2U6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWI+PQoJYXNzZXJ0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI2NQoJLy8gb3duZXJCYWxhbmNlID0gdGhpcy5hcmMyMDBfYmFsYW5jZU9mKGZyb20pCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJY2FsbHN1YiBhcmMyMDBfYmFsYW5jZU9mCglmcmFtZV9idXJ5IDEgLy8gb3duZXJCYWxhbmNlOiB1bnNhZmUgdWludDI1NgoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNjYKCS8vIGFzc2VydChvd25lckJhbGFuY2UgPj0gdmFsdWUpCglmcmFtZV9kaWcgMSAvLyBvd25lckJhbGFuY2U6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWI+PQoJYXNzZXJ0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI2OAoJLy8gYWxsb3dhbmNlQWZ0ZXIgPSA8dWludDI1Nj4oYWxsb3dhbmNlIC0gdmFsdWUpCglmcmFtZV9kaWcgMCAvLyBhbGxvd2FuY2U6IHVuc2FmZSB1aW50MjU2CglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWItCglmcmFtZV9idXJ5IDIgLy8gYWxsb3dhbmNlQWZ0ZXI6IHVuc2FmZSB1aW50MjU2CgoJLy8gaWY3X2NvbmRpdGlvbgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI2OQoJLy8gYWxsb3dhbmNlQWZ0ZXIgPiA8dWludDI1Nj4wCglmcmFtZV9kaWcgMiAvLyBhbGxvd2FuY2VBZnRlcjogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgliPgoJYnogaWY3X2Vsc2VpZjFfY29uZGl0aW9uCgoJLy8gaWY3X2NvbnNlcXVlbnQKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNzAKCS8vIHRoaXMuYWxsb3dhbmNlcyhbZnJvbSwgdGhpcy50eG4uc2VuZGVyXSkudmFsdWUgPSBhbGxvd2FuY2VBZnRlcgoJZnJhbWVfZGlnIC0xIC8vIGZyb206IEFkZHJlc3MKCXR4biBTZW5kZXIKCWNvbmNhdAoJZnJhbWVfZGlnIDIgLy8gYWxsb3dhbmNlQWZ0ZXI6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJveF9wdXQKCWIgaWY3X2VuZAoKaWY3X2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI3MQoJLy8gdGhpcy5hbGxvd2FuY2VzKFtmcm9tLCB0aGlzLnR4bi5zZW5kZXJdKS5leGlzdHMKCWZyYW1lX2RpZyAtMSAvLyBmcm9tOiBBZGRyZXNzCgl0eG4gU2VuZGVyCgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoJYnogaWY3X2VuZAoKCS8vIGlmN19lbHNlaWYxX2NvbnNlcXVlbnQKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyNzMKCS8vIHRoaXMuYWxsb3dhbmNlcyhbZnJvbSwgdGhpcy50eG4uc2VuZGVyXSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAtMSAvLyBmcm9tOiBBZGRyZXNzCgl0eG4gU2VuZGVyCgljb25jYXQKCWJveF9kZWwKCmlmN19lbmQ6CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6Mjc2CgkvLyBvd25lckJhbGFuY2VBZnRlciA9IDx1aW50MjU2Pihvd25lckJhbGFuY2UgLSB2YWx1ZSkKCWZyYW1lX2RpZyAxIC8vIG93bmVyQmFsYW5jZTogdW5zYWZlIHVpbnQyNTYKCWZyYW1lX2RpZyAtMyAvLyB2YWx1ZTogdWludDI1NgoJYi0KCWZyYW1lX2J1cnkgMyAvLyBvd25lckJhbGFuY2VBZnRlcjogdW5zYWZlIHVpbnQyNTYKCgkvLyBpZjhfY29uZGl0aW9uCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6Mjc3CgkvLyBvd25lckJhbGFuY2VBZnRlciA+IDx1aW50MjU2PjAKCWZyYW1lX2RpZyAzIC8vIG93bmVyQmFsYW5jZUFmdGVyOiB1bnNhZmUgdWludDI1NgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWI+CglieiBpZjhfZWxzZWlmMV9jb25kaXRpb24KCgkvLyBpZjhfY29uc2VxdWVudAoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI3OAoJLy8gdGhpcy5iYWxhbmNlcyhmcm9tKS52YWx1ZSA9IG93bmVyQmFsYW5jZUFmdGVyCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJZnJhbWVfZGlnIDMgLy8gb3duZXJCYWxhbmNlQWZ0ZXI6IHVuc2FmZSB1aW50MjU2CglkdXAKCWJpdGxlbgoJaW50IDI1NgoJPD0KCWFzc2VydAoJYnl0ZSAweEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYKCWImCglkdXAKCWxlbgoJZHVwCglpbnQgMzIKCS0KCXN3YXAKCXN1YnN0cmluZzMKCWJveF9wdXQKCWIgaWY4X2VuZAoKaWY4X2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI3OQoJLy8gdGhpcy5iYWxhbmNlcyhmcm9tKS5leGlzdHMKCWZyYW1lX2RpZyAtMSAvLyBmcm9tOiBBZGRyZXNzCglib3hfbGVuCglzd2FwCglwb3AKCWJ6IGlmOF9lbmQKCgkvLyBpZjhfZWxzZWlmMV9jb25zZXF1ZW50CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MjgxCgkvLyB0aGlzLmJhbGFuY2VzKGZyb20pLmRlbGV0ZSgpCglmcmFtZV9kaWcgLTEgLy8gZnJvbTogQWRkcmVzcwoJYm94X2RlbAoKaWY4X2VuZDoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czoyODQKCS8vIHJlY2VpdmVyQmFsYW5jZUFmdGVyID0gPHVpbnQyNTY+KHRoaXMuYXJjMjAwX2JhbGFuY2VPZih0bykgKyB2YWx1ZSkKCWZyYW1lX2RpZyAtMiAvLyB0bzogQWRkcmVzcwoJY2FsbHN1YiBhcmMyMDBfYmFsYW5jZU9mCglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWIrCglmcmFtZV9idXJ5IDQgLy8gcmVjZWl2ZXJCYWxhbmNlQWZ0ZXI6IHVuc2FmZSB1aW50MjU2CgoJLy8gaWY5X2NvbmRpdGlvbgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI4NQoJLy8gcmVjZWl2ZXJCYWxhbmNlQWZ0ZXIgPiA8dWludDI1Nj4wCglmcmFtZV9kaWcgNCAvLyByZWNlaXZlckJhbGFuY2VBZnRlcjogdW5zYWZlIHVpbnQyNTYKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgliPgoJYnogaWY5X2VuZAoKCS8vIGlmOV9jb25zZXF1ZW50CgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6Mjg2CgkvLyB0aGlzLmJhbGFuY2VzKHRvKS52YWx1ZSA9IHJlY2VpdmVyQmFsYW5jZUFmdGVyCglmcmFtZV9kaWcgLTIgLy8gdG86IEFkZHJlc3MKCWZyYW1lX2RpZyA0IC8vIHJlY2VpdmVyQmFsYW5jZUFmdGVyOiB1bnNhZmUgdWludDI1NgoJZHVwCgliaXRsZW4KCWludCAyNTYKCTw9Cglhc3NlcnQKCWJ5dGUgMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGCgliJgoJZHVwCglsZW4KCWR1cAoJaW50IDMyCgktCglzd2FwCglzdWJzdHJpbmczCglib3hfcHV0CgppZjlfZW5kOgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjI4OQoJLy8gdGhpcy5hcmMyMDBfVHJhbnNmZXIubG9nKHsKCS8vIAkJCWZyb206IGZyb20sCgkvLyAJCQl0bzogdG8sCgkvLyAJCQl2YWx1ZTogdmFsdWUsCgkvLyAJCX0pCglieXRlIDB4Nzk4M2MzNWMgLy8gYXJjMjAwX1RyYW5zZmVyKGFkZHJlc3MsYWRkcmVzcyx1aW50MjU2KQoJZnJhbWVfZGlnIC0xIC8vIGZyb206IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyB0bzogQWRkcmVzcwoJY29uY2F0CglmcmFtZV9kaWcgLTMgLy8gdmFsdWU6IHVpbnQyNTYKCWNvbmNhdAoJY29uY2F0Cglsb2cKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6Mjk1CgkvLyByZXR1cm4gdHJ1ZTsKCWludCAxCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNAoJcmV0c3ViCgovLyBkZWxldGVBcHBsaWNhdGlvbigpdm9pZAphYmlfcm91dGVfZGVsZXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIGRlbGV0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIGRlbGV0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBkZWxldGVBcHBsaWNhdGlvbigpOiB2b2lkCi8vCi8vIERlbGV0ZSB0aGUgYXBwIGlmIGJhbGFuY2UgdG90YWwgc3VwcGx5IGhhcyBiZWVuIGJ1cm5lZApkZWxldGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czozMDIKCS8vIGFzc2VydCh0aGlzLm1hbmFnZXIudmFsdWUgPT09IHRoaXMudHhuLnNlbmRlcikKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWFwcF9nbG9iYWxfZ2V0Cgl0eG4gU2VuZGVyCgk9PQoJYXNzZXJ0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjMwMwoJLy8gYXNzZXJ0KHRoaXMuYXJjMjAwX2JhbGFuY2VPZihnbG9iYWxzLnplcm9BZGRyZXNzKSA9PT0gdGhpcy50b3RhbFN1cHBseS52YWx1ZSkKCWdsb2JhbCBaZXJvQWRkcmVzcwoJY2FsbHN1YiBhcmMyMDBfYmFsYW5jZU9mCglieXRlIDB4NzQ2Zjc0NjE2YzUzNzU3MDcwNmM3OSAvLyAidG90YWxTdXBwbHkiCglib3hfZ2V0Cglhc3NlcnQKCWI9PQoJYXNzZXJ0CgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjMwNAoJLy8gdGhpcy5iYWxhbmNlcyhnbG9iYWxzLnplcm9BZGRyZXNzKS5kZWxldGUoKQoJZ2xvYmFsIFplcm9BZGRyZXNzCglib3hfZGVsCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjMwNQoJLy8gdGhpcy5tZXRhZGF0YS5kZWxldGUoKQoJYnl0ZSAweDZkNjU3NDYxNjQ2MTc0NjEgLy8gIm1ldGFkYXRhIgoJYm94X2RlbAoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czozMDYKCS8vIHRoaXMudG90YWxTdXBwbHkuZGVsZXRlKCkKCWJ5dGUgMHg3NDZmNzQ2MTZjNTM3NTcwNzA2Yzc5IC8vICJ0b3RhbFN1cHBseSIKCWJveF9kZWwKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MzA3CgkvLyB0aGlzLm1hbmFnZXIuZGVsZXRlKCkKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWFwcF9nbG9iYWxfZGVsCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjMwOAoJLy8gc2VuZFBheW1lbnQoewoJLy8gCQkJc2VuZGVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gCQkJcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vIAkJCWFtb3VudDogMCwKCS8vIAkJCWNsb3NlUmVtYWluZGVyVG86IHRoaXMudHhuLnNlbmRlciwKCS8vIAkJCWZlZTogZ2xvYmFscy5taW5UeG5GZWUsCgkvLyAJCX0pCglpdHhuX2JlZ2luCglpbnQgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjMwOQoJLy8gc2VuZGVyOiB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MzEwCgkvLyByZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gc3JjL2NvbnRyYWN0cy9BcmMyMDBUb2tlbi5hbGdvLnRzOjMxMQoJLy8gYW1vdW50OiAwCglpbnQgMAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBzcmMvY29udHJhY3RzL0FyYzIwMFRva2VuLmFsZ28udHM6MzEyCgkvLyBjbG9zZVJlbWFpbmRlclRvOiB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czozMTMKCS8vIGZlZTogZ2xvYmFscy5taW5UeG5GZWUKCWdsb2JhbCBNaW5UeG5GZWUKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIHNyYy9jb250cmFjdHMvQXJjMjAwVG9rZW4uYWxnby50czozMTUKCS8vIGFzc2VydCh0aGlzLmFwcC5hZGRyZXNzLmJhbGFuY2UgPT09IDApCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCglwb3AKCWludCAwCgk9PQoJYXNzZXJ0CglyZXRzdWIKCmNyZWF0ZV9Ob09wOgoJbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbihhZGRyZXNzKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCBhYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCWVycgoKY2FsbF9Ob09wOgoJbWV0aG9kICJzZXRNYW5hZ2VyKGFkZHJlc3MpYm9vbCIKCW1ldGhvZCAiaW5pdGlhbGl6ZShieXRlWzMyXSxieXRlWzhdLHVpbnQ4LHVpbnQyNTYsYWRkcmVzcyl2b2lkIgoJbWV0aG9kICJhcmMyMDBfbmFtZSgpYnl0ZVszMl0iCgltZXRob2QgImFyYzIwMF9zeW1ib2woKWJ5dGVbOF0iCgltZXRob2QgImFyYzIwMF9kZWNpbWFscygpdWludDgiCgltZXRob2QgImFyYzIwMF90b3RhbFN1cHBseSgpdWludDI1NiIKCW1ldGhvZCAiYXJjMjAwX2JhbGFuY2VPZihhZGRyZXNzKXVpbnQyNTYiCgltZXRob2QgImhhc0JhbGFuY2UoYWRkcmVzcylib29sIgoJbWV0aG9kICJoYXNBbGxvd2FuY2UoYWRkcmVzcyxhZGRyZXNzKWJvb2wiCgltZXRob2QgImFyYzIwMF9hbGxvd2FuY2UoYWRkcmVzcyxhZGRyZXNzKXVpbnQyNTYiCgltZXRob2QgImFyYzIwMF90cmFuc2ZlcihhZGRyZXNzLHVpbnQyNTYpYm9vbCIKCW1ldGhvZCAiYXJjMjAwX2FwcHJvdmUoYWRkcmVzcyx1aW50MjU2KWJvb2wiCgltZXRob2QgImFyYzIwMF90cmFuc2ZlckZyb20oYWRkcmVzcyxhZGRyZXNzLHVpbnQyNTYpYm9vbCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoIGFiaV9yb3V0ZV9zZXRNYW5hZ2VyIGFiaV9yb3V0ZV9pbml0aWFsaXplIGFiaV9yb3V0ZV9hcmMyMDBfbmFtZSBhYmlfcm91dGVfYXJjMjAwX3N5bWJvbCBhYmlfcm91dGVfYXJjMjAwX2RlY2ltYWxzIGFiaV9yb3V0ZV9hcmMyMDBfdG90YWxTdXBwbHkgYWJpX3JvdXRlX2FyYzIwMF9iYWxhbmNlT2YgYWJpX3JvdXRlX2hhc0JhbGFuY2UgYWJpX3JvdXRlX2hhc0FsbG93YW5jZSBhYmlfcm91dGVfYXJjMjAwX2FsbG93YW5jZSBhYmlfcm91dGVfYXJjMjAwX3RyYW5zZmVyIGFiaV9yb3V0ZV9hcmMyMDBfYXBwcm92ZSBhYmlfcm91dGVfYXJjMjAwX3RyYW5zZmVyRnJvbQoJZXJyCgpjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uOgoJbWV0aG9kICJ1cGRhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoIGFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbgoJZXJyCgpjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uOgoJbWV0aG9kICJkZWxldGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoIGFiaV9yb3V0ZV9kZWxldGVBcHBsaWNhdGlvbgoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "Arc200Token",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "args": [
          {
            "name": "manager",
            "type": "address"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "updateApplication",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "setManager",
        "args": [
          {
            "name": "manager",
            "type": "address"
          }
        ],
        "returns": {
          "type": "bool"
        }
      },
      {
        "name": "initialize",
        "desc": "Initialize ARC200",
        "args": [
          {
            "name": "name",
            "type": "byte[32]",
            "desc": "token name"
          },
          {
            "name": "symbol",
            "type": "byte[8]",
            "desc": "token symbol"
          },
          {
            "name": "decimals",
            "type": "uint8",
            "desc": "number of decimals"
          },
          {
            "name": "totalSupply",
            "type": "uint256",
            "desc": "total supply of tokens"
          },
          {
            "name": "mintTo",
            "type": "address",
            "desc": "initial mint to"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "arc200_name",
        "desc": "The name of the token",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "byte[32]",
          "desc": "The name of the token"
        }
      },
      {
        "name": "arc200_symbol",
        "desc": "Returns the symbol of the token",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "byte[8]",
          "desc": "The symbol of the token"
        }
      },
      {
        "name": "arc200_decimals",
        "desc": "Returns the decimals of the token",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint8",
          "desc": "The decimals of the token"
        }
      },
      {
        "name": "arc200_totalSupply",
        "desc": "Returns the total supply of the token",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint256",
          "desc": "The total supply of the token"
        }
      },
      {
        "name": "arc200_balanceOf",
        "desc": "Returns the current balance of the owner of the token",
        "readonly": true,
        "args": [
          {
            "name": "owner",
            "type": "address",
            "desc": "The address of the owner of the token"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "The current balance of the holder of the token"
        }
      },
      {
        "name": "hasBalance",
        "desc": "Check if balance box exists",
        "readonly": true,
        "args": [
          {
            "name": "owner",
            "type": "address",
            "desc": "The address of the owner"
          }
        ],
        "returns": {
          "type": "bool",
          "desc": "`true`if balance box exists"
        }
      },
      {
        "name": "hasAllowance",
        "desc": "Check if allowance box exists",
        "readonly": true,
        "args": [
          {
            "name": "owner",
            "type": "address",
            "desc": "The address of the owner"
          },
          {
            "name": "spender",
            "type": "address",
            "desc": "The address of the spender"
          }
        ],
        "returns": {
          "type": "bool",
          "desc": "`true`if allowance box exists"
        }
      },
      {
        "name": "arc200_allowance",
        "desc": "Returns the current allowance of the spender of the tokens of the owner",
        "readonly": true,
        "args": [
          {
            "name": "owner",
            "type": "address"
          },
          {
            "name": "spender",
            "type": "address"
          }
        ],
        "returns": {
          "type": "uint256",
          "desc": "The remaining allowance"
        }
      },
      {
        "name": "arc200_transfer",
        "desc": "Transfers tokens",
        "args": [
          {
            "name": "to",
            "type": "address",
            "desc": "The destination of the transfer"
          },
          {
            "name": "value",
            "type": "uint256",
            "desc": "Amount of tokens to transfer"
          }
        ],
        "returns": {
          "type": "bool",
          "desc": "Success"
        }
      },
      {
        "name": "arc200_approve",
        "desc": "Approve spender for a token",
        "args": [
          {
            "name": "spender",
            "type": "address"
          },
          {
            "name": "value",
            "type": "uint256"
          }
        ],
        "returns": {
          "type": "bool",
          "desc": "Success"
        }
      },
      {
        "name": "arc200_transferFrom",
        "desc": "Transfers tokens from source to destination as approved spender",
        "args": [
          {
            "name": "from",
            "type": "address",
            "desc": "The source  of the transfer"
          },
          {
            "name": "to",
            "type": "address",
            "desc": "The destination of the transfer"
          },
          {
            "name": "value",
            "type": "uint256",
            "desc": "Amount of tokens to transfer"
          }
        ],
        "returns": {
          "type": "bool",
          "desc": "Success"
        },
        "events": [
          {
            "name": "arc200_Transfer",
            "args": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "desc": "Transfer of tokens"
          }
        ]
      },
      {
        "name": "deleteApplication",
        "desc": "Delete the app if balance total supply has been burned",
        "args": [],
        "returns": {
          "type": "void"
        }
      }
    ],
    "events": [
      {
        "name": "arc200_Transfer",
        "args": [
          {
            "name": "from",
            "type": "address"
          },
          {
            "name": "to",
            "type": "address"
          },
          {
            "name": "value",
            "type": "uint256"
          }
        ],
        "desc": "Transfer of tokens"
      },
      {
        "name": "arc200_Approval",
        "args": [
          {
            "name": "owner",
            "type": "address"
          },
          {
            "name": "spender",
            "type": "address"
          },
          {
            "name": "value",
            "type": "uint256"
          }
        ],
        "desc": "Approval of tokens"
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

/**
 * Defines the types of available calls and state of the Arc200Token smart contract.
 */
export type Arc200Token = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication(address)void' | 'createApplication', {
      argsObj: {
        manager: string
      }
      argsTuple: [manager: string]
      returns: void
    }>
    & Record<'updateApplication()void' | 'updateApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'setManager(address)bool' | 'setManager', {
      argsObj: {
        manager: string
      }
      argsTuple: [manager: string]
      returns: boolean
    }>
    & Record<'initialize(byte[32],byte[8],uint8,uint256,address)void' | 'initialize', {
      argsObj: {
        /**
         * token name
         */
        name: Uint8Array
        /**
         * token symbol
         */
        symbol: Uint8Array
        /**
         * number of decimals
         */
        decimals: number
        /**
         * total supply of tokens
         */
        totalSupply: bigint | number
        /**
         * initial mint to
         */
        mintTo: string
      }
      argsTuple: [name: Uint8Array, symbol: Uint8Array, decimals: number, totalSupply: bigint | number, mintTo: string]
      returns: void
    }>
    & Record<'arc200_name()byte[32]' | 'arc200_name', {
      argsObj: {
      }
      argsTuple: []
      /**
       * The name of the token
       */
      returns: Uint8Array
    }>
    & Record<'arc200_symbol()byte[8]' | 'arc200_symbol', {
      argsObj: {
      }
      argsTuple: []
      /**
       * The symbol of the token
       */
      returns: Uint8Array
    }>
    & Record<'arc200_decimals()uint8' | 'arc200_decimals', {
      argsObj: {
      }
      argsTuple: []
      /**
       * The decimals of the token
       */
      returns: number
    }>
    & Record<'arc200_totalSupply()uint256' | 'arc200_totalSupply', {
      argsObj: {
      }
      argsTuple: []
      /**
       * The total supply of the token
       */
      returns: bigint
    }>
    & Record<'arc200_balanceOf(address)uint256' | 'arc200_balanceOf', {
      argsObj: {
        /**
         * The address of the owner of the token
         */
        owner: string
      }
      argsTuple: [owner: string]
      /**
       * The current balance of the holder of the token
       */
      returns: bigint
    }>
    & Record<'hasBalance(address)bool' | 'hasBalance', {
      argsObj: {
        /**
         * The address of the owner
         */
        owner: string
      }
      argsTuple: [owner: string]
      /**
       * `true`if balance box exists
       */
      returns: boolean
    }>
    & Record<'hasAllowance(address,address)bool' | 'hasAllowance', {
      argsObj: {
        /**
         * The address of the owner
         */
        owner: string
        /**
         * The address of the spender
         */
        spender: string
      }
      argsTuple: [owner: string, spender: string]
      /**
       * `true`if allowance box exists
       */
      returns: boolean
    }>
    & Record<'arc200_allowance(address,address)uint256' | 'arc200_allowance', {
      argsObj: {
        owner: string
        spender: string
      }
      argsTuple: [owner: string, spender: string]
      /**
       * The remaining allowance
       */
      returns: bigint
    }>
    & Record<'arc200_transfer(address,uint256)bool' | 'arc200_transfer', {
      argsObj: {
        /**
         * The destination of the transfer
         */
        to: string
        /**
         * Amount of tokens to transfer
         */
        value: bigint | number
      }
      argsTuple: [to: string, value: bigint | number]
      /**
       * Success
       */
      returns: boolean
    }>
    & Record<'arc200_approve(address,uint256)bool' | 'arc200_approve', {
      argsObj: {
        spender: string
        value: bigint | number
      }
      argsTuple: [spender: string, value: bigint | number]
      /**
       * Success
       */
      returns: boolean
    }>
    & Record<'arc200_transferFrom(address,address,uint256)bool' | 'arc200_transferFrom', {
      argsObj: {
        /**
         * The source  of the transfer
         */
        from: string
        /**
         * The destination of the transfer
         */
        to: string
        /**
         * Amount of tokens to transfer
         */
        value: bigint | number
      }
      argsTuple: [from: string, to: string, value: bigint | number]
      /**
       * Success
       */
      returns: boolean
    }>
    & Record<'deleteApplication()void' | 'deleteApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'manager'?: BinaryState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type Arc200TokenSig = keyof Arc200Token['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends Arc200TokenSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the Arc200Token smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends Arc200TokenSig> = Arc200Token['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the Arc200Token smart contract to the method's return type
 */
export type MethodReturn<TSignature extends Arc200TokenSig> = Arc200Token['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type Arc200TokenCreateCalls = (typeof Arc200TokenCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type Arc200TokenCreateCallParams =
  | (TypedCallParams<'createApplication(address)void'> & (OnCompleteNoOp))
/**
 * A factory for available 'update' calls
 */
export type Arc200TokenUpdateCalls = (typeof Arc200TokenCallFactory)['update']
/**
 * Defines supported update methods for this smart contract
 */
export type Arc200TokenUpdateCallParams =
  | TypedCallParams<'updateApplication()void'>
/**
 * A factory for available 'delete' calls
 */
export type Arc200TokenDeleteCalls = (typeof Arc200TokenCallFactory)['delete']
/**
 * Defines supported delete methods for this smart contract
 */
export type Arc200TokenDeleteCallParams =
  | TypedCallParams<'deleteApplication()void'>
/**
 * Defines arguments required for the deploy method.
 */
export type Arc200TokenDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: Arc200TokenCreateCalls) => Arc200TokenCreateCallParams
  /**
   * A delegate which takes a update call factory and returns the update call params for this smart contract
   */
  updateCall?: (callFactory: Arc200TokenUpdateCalls) => Arc200TokenUpdateCallParams
  /**
   * A delegate which takes a delete call factory and returns the delete call params for this smart contract
   */
  deleteCall?: (callFactory: Arc200TokenDeleteCalls) => Arc200TokenDeleteCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class Arc200TokenCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the Arc200Token smart contract using the createApplication(address)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication(address)void' as const,
          methodArgs: Array.isArray(args) ? args : [args.manager],
          ...params,
        }
      },
    }
  }

  /**
   * Gets available update call factories
   */
  static get update() {
    return {
      /**
       * Constructs an update call for the Arc200Token smart contract using the updateApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      updateApplication(args: MethodArgs<'updateApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {
        return {
          method: 'updateApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Gets available delete call factories
   */
  static get delete() {
    return {
      /**
       * Constructs a delete call for the Arc200Token smart contract using the deleteApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      deleteApplication(args: MethodArgs<'deleteApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return {
          method: 'deleteApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the setManager(address)bool ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setManager(args: MethodArgs<'setManager(address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'setManager(address)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.manager],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the initialize(byte[32],byte[8],uint8,uint256,address)void ABI method
   *
   * Initialize ARC200
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static initialize(args: MethodArgs<'initialize(byte[32],byte[8],uint8,uint256,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'initialize(byte[32],byte[8],uint8,uint256,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.name, args.symbol, args.decimals, args.totalSupply, args.mintTo],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_name()byte[32] ABI method
   *
   * The name of the token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200Name(args: MethodArgs<'arc200_name()byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_name()byte[32]' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_symbol()byte[8] ABI method
   *
   * Returns the symbol of the token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200Symbol(args: MethodArgs<'arc200_symbol()byte[8]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_symbol()byte[8]' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_decimals()uint8 ABI method
   *
   * Returns the decimals of the token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200Decimals(args: MethodArgs<'arc200_decimals()uint8'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_decimals()uint8' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_totalSupply()uint256 ABI method
   *
   * Returns the total supply of the token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200TotalSupply(args: MethodArgs<'arc200_totalSupply()uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_totalSupply()uint256' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_balanceOf(address)uint256 ABI method
   *
   * Returns the current balance of the owner of the token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200BalanceOf(args: MethodArgs<'arc200_balanceOf(address)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_balanceOf(address)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the hasBalance(address)bool ABI method
   *
   * Check if balance box exists
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static hasBalance(args: MethodArgs<'hasBalance(address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'hasBalance(address)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the hasAllowance(address,address)bool ABI method
   *
   * Check if allowance box exists
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static hasAllowance(args: MethodArgs<'hasAllowance(address,address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'hasAllowance(address,address)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner, args.spender],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_allowance(address,address)uint256 ABI method
   *
   * Returns the current allowance of the spender of the tokens of the owner
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200Allowance(args: MethodArgs<'arc200_allowance(address,address)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_allowance(address,address)uint256' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner, args.spender],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_transfer(address,uint256)bool ABI method
   *
   * Transfers tokens
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200Transfer(args: MethodArgs<'arc200_transfer(address,uint256)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_transfer(address,uint256)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.to, args.value],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_approve(address,uint256)bool ABI method
   *
   * Approve spender for a token
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200Approve(args: MethodArgs<'arc200_approve(address,uint256)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_approve(address,uint256)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.spender, args.value],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc200_transferFrom(address,address,uint256)bool ABI method
   *
   * Transfers tokens from source to destination as approved spender
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc200TransferFrom(args: MethodArgs<'arc200_transferFrom(address,address,uint256)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc200_transferFrom(address,address,uint256)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.from, args.to, args.value],
      ...params,
    }
  }
}

/**
 * A client to make calls to the Arc200Token smart contract
 */
export class Arc200TokenClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `Arc200TokenClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof Arc200Token['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the Arc200Token smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: Arc200TokenDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(Arc200TokenCallFactory.create)
    const updateArgs = params.updateCall?.(Arc200TokenCallFactory.update)
    const deleteArgs = params.deleteCall?.(Arc200TokenCallFactory.delete)
    return this.appClient.deploy({
      ...params,
      updateArgs,
      deleteArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the Arc200Token smart contract using the createApplication(address)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication(address)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication(address)void'>, AppCreateCallTransactionResult>(await $this.appClient.create(Arc200TokenCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Gets available update methods
   */
  public get update() {
    const $this = this
    return {
      /**
       * Updates an existing instance of the Arc200Token smart contract using the updateApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The update result
       */
      async updateApplication(args: MethodArgs<'updateApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams = {}) {
        return $this.mapReturnValue<MethodReturn<'updateApplication()void'>, AppUpdateCallTransactionResult>(await $this.appClient.update(Arc200TokenCallFactory.update.updateApplication(args, params)))
      },
    }
  }

  /**
   * Gets available delete methods
   */
  public get delete() {
    const $this = this
    return {
      /**
       * Deletes an existing instance of the Arc200Token smart contract using the deleteApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The delete result
       */
      async deleteApplication(args: MethodArgs<'deleteApplication()void'>, params: AppClientCallCoreParams = {}) {
        return $this.mapReturnValue<MethodReturn<'deleteApplication()void'>>(await $this.appClient.delete(Arc200TokenCallFactory.delete.deleteApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the Arc200Token smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the setManager(address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setManager(args: MethodArgs<'setManager(address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.setManager(args, params))
  }

  /**
   * Calls the initialize(byte[32],byte[8],uint8,uint256,address)void ABI method.
   *
   * Initialize ARC200
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public initialize(args: MethodArgs<'initialize(byte[32],byte[8],uint8,uint256,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.initialize(args, params))
  }

  /**
   * Calls the arc200_name()byte[32] ABI method.
   *
   * The name of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The name of the token
   */
  public arc200Name(args: MethodArgs<'arc200_name()byte[32]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200Name(args, params))
  }

  /**
   * Calls the arc200_symbol()byte[8] ABI method.
   *
   * Returns the symbol of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The symbol of the token
   */
  public arc200Symbol(args: MethodArgs<'arc200_symbol()byte[8]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200Symbol(args, params))
  }

  /**
   * Calls the arc200_decimals()uint8 ABI method.
   *
   * Returns the decimals of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The decimals of the token
   */
  public arc200Decimals(args: MethodArgs<'arc200_decimals()uint8'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200Decimals(args, params))
  }

  /**
   * Calls the arc200_totalSupply()uint256 ABI method.
   *
   * Returns the total supply of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The total supply of the token
   */
  public arc200TotalSupply(args: MethodArgs<'arc200_totalSupply()uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200TotalSupply(args, params))
  }

  /**
   * Calls the arc200_balanceOf(address)uint256 ABI method.
   *
   * Returns the current balance of the owner of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The current balance of the holder of the token
   */
  public arc200BalanceOf(args: MethodArgs<'arc200_balanceOf(address)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200BalanceOf(args, params))
  }

  /**
   * Calls the hasBalance(address)bool ABI method.
   *
   * Check if balance box exists
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: `true`if balance box exists
   */
  public hasBalance(args: MethodArgs<'hasBalance(address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.hasBalance(args, params))
  }

  /**
   * Calls the hasAllowance(address,address)bool ABI method.
   *
   * Check if allowance box exists
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: `true`if allowance box exists
   */
  public hasAllowance(args: MethodArgs<'hasAllowance(address,address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.hasAllowance(args, params))
  }

  /**
   * Calls the arc200_allowance(address,address)uint256 ABI method.
   *
   * Returns the current allowance of the spender of the tokens of the owner
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The remaining allowance
   */
  public arc200Allowance(args: MethodArgs<'arc200_allowance(address,address)uint256'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200Allowance(args, params))
  }

  /**
   * Calls the arc200_transfer(address,uint256)bool ABI method.
   *
   * Transfers tokens
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Success
   */
  public arc200Transfer(args: MethodArgs<'arc200_transfer(address,uint256)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200Transfer(args, params))
  }

  /**
   * Calls the arc200_approve(address,uint256)bool ABI method.
   *
   * Approve spender for a token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Success
   */
  public arc200Approve(args: MethodArgs<'arc200_approve(address,uint256)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200Approve(args, params))
  }

  /**
   * Calls the arc200_transferFrom(address,address,uint256)bool ABI method.
   *
   * Transfers tokens from source to destination as approved spender
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Success
   */
  public arc200TransferFrom(args: MethodArgs<'arc200_transferFrom(address,address,uint256)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(Arc200TokenCallFactory.arc200TransferFrom(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<Arc200Token['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get manager() {
        return Arc200TokenClient.getBinaryState(state, 'manager')
      },
    }
  }

  public compose(): Arc200TokenComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      setManager(args: MethodArgs<'setManager(address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.setManager(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      initialize(args: MethodArgs<'initialize(byte[32],byte[8],uint8,uint256,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.initialize(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200Name(args: MethodArgs<'arc200_name()byte[32]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200Name(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200Symbol(args: MethodArgs<'arc200_symbol()byte[8]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200Symbol(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200Decimals(args: MethodArgs<'arc200_decimals()uint8'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200Decimals(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200TotalSupply(args: MethodArgs<'arc200_totalSupply()uint256'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200TotalSupply(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200BalanceOf(args: MethodArgs<'arc200_balanceOf(address)uint256'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200BalanceOf(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      hasBalance(args: MethodArgs<'hasBalance(address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.hasBalance(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      hasAllowance(args: MethodArgs<'hasAllowance(address,address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.hasAllowance(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200Allowance(args: MethodArgs<'arc200_allowance(address,address)uint256'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200Allowance(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200Transfer(args: MethodArgs<'arc200_transfer(address,uint256)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200Transfer(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200Approve(args: MethodArgs<'arc200_approve(address,uint256)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200Approve(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc200TransferFrom(args: MethodArgs<'arc200_transferFrom(address,address,uint256)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc200TransferFrom(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      get update() {
        const $this = this
        return {
          updateApplication(args: MethodArgs<'updateApplication()void'>, params?: AppClientComposeCallCoreParams & AppClientCompilationParams) {
            promiseChain = promiseChain.then(() => client.update.updateApplication(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(undefined)
            return $this
          },
        }
      },
      get delete() {
        const $this = this
        return {
          deleteApplication(args: MethodArgs<'deleteApplication()void'>, params?: AppClientComposeCallCoreParams) {
            promiseChain = promiseChain.then(() => client.delete.deleteApplication(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(undefined)
            return $this
          },
        }
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as Arc200TokenComposer
  }
}
export type Arc200TokenComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the setManager(address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setManager(args: MethodArgs<'setManager(address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'setManager(address)bool'>]>

  /**
   * Calls the initialize(byte[32],byte[8],uint8,uint256,address)void ABI method.
   *
   * Initialize ARC200
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initialize(args: MethodArgs<'initialize(byte[32],byte[8],uint8,uint256,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'initialize(byte[32],byte[8],uint8,uint256,address)void'>]>

  /**
   * Calls the arc200_name()byte[32] ABI method.
   *
   * The name of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200Name(args: MethodArgs<'arc200_name()byte[32]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_name()byte[32]'>]>

  /**
   * Calls the arc200_symbol()byte[8] ABI method.
   *
   * Returns the symbol of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200Symbol(args: MethodArgs<'arc200_symbol()byte[8]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_symbol()byte[8]'>]>

  /**
   * Calls the arc200_decimals()uint8 ABI method.
   *
   * Returns the decimals of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200Decimals(args: MethodArgs<'arc200_decimals()uint8'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_decimals()uint8'>]>

  /**
   * Calls the arc200_totalSupply()uint256 ABI method.
   *
   * Returns the total supply of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200TotalSupply(args: MethodArgs<'arc200_totalSupply()uint256'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_totalSupply()uint256'>]>

  /**
   * Calls the arc200_balanceOf(address)uint256 ABI method.
   *
   * Returns the current balance of the owner of the token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200BalanceOf(args: MethodArgs<'arc200_balanceOf(address)uint256'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_balanceOf(address)uint256'>]>

  /**
   * Calls the hasBalance(address)bool ABI method.
   *
   * Check if balance box exists
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  hasBalance(args: MethodArgs<'hasBalance(address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'hasBalance(address)bool'>]>

  /**
   * Calls the hasAllowance(address,address)bool ABI method.
   *
   * Check if allowance box exists
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  hasAllowance(args: MethodArgs<'hasAllowance(address,address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'hasAllowance(address,address)bool'>]>

  /**
   * Calls the arc200_allowance(address,address)uint256 ABI method.
   *
   * Returns the current allowance of the spender of the tokens of the owner
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200Allowance(args: MethodArgs<'arc200_allowance(address,address)uint256'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_allowance(address,address)uint256'>]>

  /**
   * Calls the arc200_transfer(address,uint256)bool ABI method.
   *
   * Transfers tokens
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200Transfer(args: MethodArgs<'arc200_transfer(address,uint256)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_transfer(address,uint256)bool'>]>

  /**
   * Calls the arc200_approve(address,uint256)bool ABI method.
   *
   * Approve spender for a token
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200Approve(args: MethodArgs<'arc200_approve(address,uint256)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_approve(address,uint256)bool'>]>

  /**
   * Calls the arc200_transferFrom(address,address,uint256)bool ABI method.
   *
   * Transfers tokens from source to destination as approved spender
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc200TransferFrom(args: MethodArgs<'arc200_transferFrom(address,address,uint256)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, MethodReturn<'arc200_transferFrom(address,address,uint256)bool'>]>

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the Arc200Token smart contract using the updateApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateApplication(args: MethodArgs<'updateApplication()void'>, params?: AppClientComposeCallCoreParams & AppClientCompilationParams): Arc200TokenComposer<[...TReturns, MethodReturn<'updateApplication()void'>]>
  }

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the Arc200Token smart contract using the deleteApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteApplication(args: MethodArgs<'deleteApplication()void'>, params?: AppClientComposeCallCoreParams): Arc200TokenComposer<[...TReturns, MethodReturn<'deleteApplication()void'>]>
  }

  /**
   * Makes a clear_state call to an existing instance of the Arc200Token smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): Arc200TokenComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): Arc200TokenComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<Arc200TokenComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<Arc200TokenComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type Arc200TokenComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type Arc200TokenComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
