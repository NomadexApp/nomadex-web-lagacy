#pragma version 10

// This TEAL was generated by TEALScript v0.80.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_UpdateApplication NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// createApplication(address,uint64)void
abi_route_createApplication:
	// fee: uint64
	txna ApplicationArgs 2
	btoi

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute createApplication(address,uint64)void
	callsub createApplication
	int 1
	return

// createApplication(owner: Address, fee: uint64): void
createApplication:
	proto 2 0

	// src/contracts/LimitOrders.algo.ts:23
	// this.orderCounter.value = 0
	byte 0x6f726465725f636f756e746572 // "order_counter"
	int 0
	app_global_put

	// src/contracts/LimitOrders.algo.ts:24
	// this.owner.value = owner
	byte 0x6f776e6572 // "owner"
	frame_dig -1 // owner: Address
	app_global_put

	// src/contracts/LimitOrders.algo.ts:25
	// this.fee.value = fee
	byte 0x666565 // "fee"
	frame_dig -2 // fee: uint64
	app_global_put

	// src/contracts/LimitOrders.algo.ts:26
	// this.feeAccumulated.value = 0
	byte 0x6665655f616363 // "fee_acc"
	int 0
	app_global_put
	retsub

// updateApplication()void
abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	int 1
	return

// updateApplication(): void
updateApplication:
	proto 0 0

	// src/contracts/LimitOrders.algo.ts:30
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert
	retsub

// setFee(uint64)void
abi_route_setFee:
	// ownerFee: uint64
	txna ApplicationArgs 1
	btoi

	// execute setFee(uint64)void
	callsub setFee
	int 1
	return

// setFee(ownerFee: uint64): void
setFee:
	proto 1 0

	// src/contracts/LimitOrders.algo.ts:34
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert

	// src/contracts/LimitOrders.algo.ts:35
	// this.fee.value = ownerFee
	byte 0x666565 // "fee"
	frame_dig -1 // ownerFee: uint64
	app_global_put
	retsub

// setOwner(address)void
abi_route_setOwner:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setOwner(address)void
	callsub setOwner
	int 1
	return

// setOwner(newOwner: Address): void
setOwner:
	proto 1 0

	// src/contracts/LimitOrders.algo.ts:39
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert

	// src/contracts/LimitOrders.algo.ts:40
	// this.owner.value = newOwner
	byte 0x6f776e6572 // "owner"
	frame_dig -1 // newOwner: Address
	app_global_put
	retsub

// collectFee(uint64)void
abi_route_collectFee:
	// algoAmount: uint64
	txna ApplicationArgs 1
	btoi

	// execute collectFee(uint64)void
	callsub collectFee
	int 1
	return

// collectFee(algoAmount: uint64): void
collectFee:
	proto 1 0

	// src/contracts/LimitOrders.algo.ts:44
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert

	// src/contracts/LimitOrders.algo.ts:45
	// this.transferTo(this.txn.sender, algoAmount)
	frame_dig -1 // algoAmount: uint64
	txn Sender
	callsub transferTo
	retsub

// transferTo(to: Address, amount: uint64): boolean
//
// *********************************************
transferTo:
	proto 2 1

	// src/contracts/LimitOrders.algo.ts:51
	// sendPayment({
	// 			sender: this.app.address,
	// 			receiver: to,
	// 			amount: amount,
	// 			fee: 1000,
	// 		})
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/contracts/LimitOrders.algo.ts:52
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:53
	// receiver: to
	frame_dig -1 // to: Address
	itxn_field Receiver

	// src/contracts/LimitOrders.algo.ts:54
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// src/contracts/LimitOrders.algo.ts:55
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/contracts/LimitOrders.algo.ts:57
	// return true;
	int 1
	retsub

// arc200TransferTo(arc200Id: Application, to: Address, amount: uint256): boolean
arc200TransferTo:
	proto 3 1

	// src/contracts/LimitOrders.algo.ts:61
	// return sendMethodCall<[Address, uint256], boolean>({
	// 			sender: this.app.address,
	// 			name: 'arc200_transfer',
	// 			applicationID: arc200Id,
	// 			methodArgs: [to, <uint256>amount],
	// 			fee: 1000,
	// 		});
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "arc200_transfer(address,uint256)bool"
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:62
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:64
	// applicationID: arc200Id
	frame_dig -1 // arc200Id: Application
	itxn_field ApplicationID

	// src/contracts/LimitOrders.algo.ts:65
	// methodArgs: [to, <uint256>amount]
	frame_dig -2 // to: Address
	itxn_field ApplicationArgs
	frame_dig -3 // amount: uint256
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:66
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	retsub

// arc200TranferFrom(arc200Id: Application, from: Address, to: Address, amount: uint256): boolean
arc200TranferFrom:
	proto 4 1

	// src/contracts/LimitOrders.algo.ts:71
	// return sendMethodCall<[Address, Address, uint256], boolean>({
	// 			sender: this.app.address,
	// 			name: 'arc200_transferFrom',
	// 			applicationID: arc200Id,
	// 			methodArgs: [from, to, amount],
	// 			fee: 1000,
	// 		});
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "arc200_transferFrom(address,address,uint256)bool"
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:72
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:74
	// applicationID: arc200Id
	frame_dig -1 // arc200Id: Application
	itxn_field ApplicationID

	// src/contracts/LimitOrders.algo.ts:75
	// methodArgs: [from, to, amount]
	frame_dig -2 // from: Address
	itxn_field ApplicationArgs
	frame_dig -3 // to: Address
	itxn_field ApplicationArgs
	frame_dig -4 // amount: uint256
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:76
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	retsub

// createAlgoSellOrder(pay,application,uint256)void
abi_route_createAlgoSellOrder:
	// arc200Amount: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// arc200Id: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// algoPayTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute createAlgoSellOrder(pay,application,uint256)void
	callsub createAlgoSellOrder
	int 1
	return

// createAlgoSellOrder(algoPayTxn: PayTxn, arc200Id: Application, arc200Amount: uint256): void
createAlgoSellOrder:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/contracts/LimitOrders.algo.ts:107
	// verifyPayTxn(algoPayTxn, {
	// 			amount: { greaterThan: 0 },
	// 			sender: this.txn.sender,
	// 			receiver: this.app.address,
	// 			rekeyTo: globals.zeroAddress,
	// 			closeRemainderTo: globals.zeroAddress,
	// 		})
	// verify amount
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Amount
	int 0
	>
	assert

	// verify sender
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify receiver
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify rekeyTo
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns RekeyTo
	global ZeroAddress
	==
	assert

	// verify closeRemainderTo
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns CloseRemainderTo
	global ZeroAddress
	==
	assert

	// src/contracts/LimitOrders.algo.ts:115
	// orderId = this.orderCounter.value
	byte 0x6f726465725f636f756e746572 // "order_counter"
	app_global_get
	frame_bury 0 // orderId: uint64

	// src/contracts/LimitOrders.algo.ts:116
	// assert(!this.orderbook(orderId).exists)
	frame_dig 0 // orderId: uint64
	itob
	box_len
	swap
	pop
	!
	assert

	// src/contracts/LimitOrders.algo.ts:118
	// this.orderbook(orderId).value = {
	// 			maker: this.txn.sender,
	// 			arc200Id: arc200Id,
	// 			algoAmount: algoPayTxn.amount,
	// 			arc200Amount: arc200Amount,
	// 			isBuyingAlgo: 0,
	// 		}
	frame_dig 0 // orderId: uint64
	itob
	txn Sender
	frame_dig -2 // arc200Id: Application
	itob
	concat
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Amount
	itob
	concat
	frame_dig -3 // arc200Amount: uint256
	concat
	byte 0x00
	concat
	box_put

	// src/contracts/LimitOrders.algo.ts:126
	// this.PlaceOrder.log({
	// 			orderId: orderId,
	// 			maker: this.txn.sender,
	// 			algoAmount: algoPayTxn.amount,
	// 			arc200Amount: arc200Amount,
	// 			orderDirection: 0,
	// 		})
	byte 0xe0ce885e // PlaceOrder(uint64,address,uint64,uint256,uint8)
	frame_dig 0 // orderId: uint64
	itob
	txn Sender
	concat
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Amount
	itob
	concat
	frame_dig -3 // arc200Amount: uint256
	concat
	byte 0x00
	concat
	concat
	log

	// src/contracts/LimitOrders.algo.ts:134
	// this.orderCounter.value = orderId + 1
	byte 0x6f726465725f636f756e746572 // "order_counter"
	frame_dig 0 // orderId: uint64
	int 1
	+
	app_global_put
	retsub

// createAlgoBuyOrder(application,uint256,uint64)void
abi_route_createAlgoBuyOrder:
	// algoAmount: uint64
	txna ApplicationArgs 3
	btoi

	// arc200Amount: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// arc200AppId: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute createAlgoBuyOrder(application,uint256,uint64)void
	callsub createAlgoBuyOrder
	int 1
	return

// createAlgoBuyOrder(arc200AppId: Application, arc200Amount: uint256, algoAmount: uint64): void
createAlgoBuyOrder:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/contracts/LimitOrders.algo.ts:138
	// orderId = this.orderCounter.value
	byte 0x6f726465725f636f756e746572 // "order_counter"
	app_global_get
	frame_bury 0 // orderId: uint64

	// src/contracts/LimitOrders.algo.ts:139
	// assert(!this.orderbook(orderId).exists)
	frame_dig 0 // orderId: uint64
	itob
	box_len
	swap
	pop
	!
	assert

	// src/contracts/LimitOrders.algo.ts:141
	// this.arc200TranferFrom(arc200AppId, this.txn.sender, this.app.address, arc200Amount)
	frame_dig -2 // arc200Amount: uint256
	global CurrentApplicationAddress
	txn Sender
	frame_dig -1 // arc200AppId: Application
	callsub arc200TranferFrom

	// src/contracts/LimitOrders.algo.ts:143
	// this.orderbook(orderId).value = {
	// 			maker: this.txn.sender,
	// 			arc200Id: arc200AppId,
	// 			algoAmount: algoAmount,
	// 			arc200Amount: arc200Amount,
	// 			isBuyingAlgo: 1,
	// 		}
	frame_dig 0 // orderId: uint64
	itob
	txn Sender
	frame_dig -1 // arc200AppId: Application
	itob
	concat
	frame_dig -3 // algoAmount: uint64
	itob
	concat
	frame_dig -2 // arc200Amount: uint256
	concat
	byte 0x01
	concat
	box_put

	// src/contracts/LimitOrders.algo.ts:151
	// this.PlaceOrder.log({
	// 			orderId: this.orderCounter.value,
	// 			maker: this.txn.sender,
	// 			algoAmount: algoAmount,
	// 			arc200Amount: arc200Amount,
	// 			orderDirection: 1,
	// 		})
	byte 0xe0ce885e // PlaceOrder(uint64,address,uint64,uint256,uint8)
	byte 0x6f726465725f636f756e746572 // "order_counter"
	app_global_get
	itob
	txn Sender
	concat
	frame_dig -3 // algoAmount: uint64
	itob
	concat
	frame_dig -2 // arc200Amount: uint256
	concat
	byte 0x01
	concat
	concat
	log

	// src/contracts/LimitOrders.algo.ts:159
	// this.orderCounter.value = orderId + 1
	byte 0x6f726465725f636f756e746572 // "order_counter"
	frame_dig 0 // orderId: uint64
	int 1
	+
	app_global_put
	retsub

// fillAlgoToArc200Order(uint64,uint256)void
abi_route_fillAlgoToArc200Order:
	// arc200Amount: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute fillAlgoToArc200Order(uint64,uint256)void
	callsub fillAlgoToArc200Order
	int 1
	return

// fillAlgoToArc200Order(orderId: uint64, arc200Amount: uint256): void
fillAlgoToArc200Order:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// src/contracts/LimitOrders.algo.ts:163
	// assert(arc200Amount > 0)
	frame_dig -2 // arc200Amount: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	assert

	// src/contracts/LimitOrders.algo.ts:164
	// assert(this.orderbook(orderId).exists)
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop
	assert

	// src/contracts/LimitOrders.algo.ts:165
	// boxSnap = this.orderbook(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//boxSnap

	// src/contracts/LimitOrders.algo.ts:167
	// assert(boxSnap.isBuyingAlgo === 0)
	int 80 // headOffset
	int 1
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	int 0
	==
	assert

	// src/contracts/LimitOrders.algo.ts:169
	// this.arc200TranferFrom(boxSnap.arc200Id, this.txn.sender, boxSnap.maker, arc200Amount)
	frame_dig -2 // arc200Amount: uint256
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	txn Sender
	int 32 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	callsub arc200TranferFrom

	// src/contracts/LimitOrders.algo.ts:171
	// _amountOfAlgos = (arc200Amount * <uint256>boxSnap.algoAmount) / boxSnap.arc200Amount
	frame_dig -2 // arc200Amount: uint256
	int 40 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	b*
	int 48 // headOffset
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	b/
	frame_bury 1 // _amountOfAlgos: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:173
	// amountOfAlgos = <uint<64>>_amountOfAlgos
	frame_dig 1 // _amountOfAlgos: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 2 // amountOfAlgos: uint64

	// src/contracts/LimitOrders.algo.ts:176
	// newArc200Amount = boxSnap.arc200Amount - arc200Amount
	int 48 // headOffset
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	frame_dig -2 // arc200Amount: uint256
	b-
	frame_bury 3 // newArc200Amount: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:179
	// newAlgoAmount = boxSnap.algoAmount - amountOfAlgos
	int 40 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	frame_dig 2 // amountOfAlgos: uint64
	-
	frame_bury 4 // newAlgoAmount: uint64

	// src/contracts/LimitOrders.algo.ts:181
	// denominator = <uint256>amountOfAlgos * <uint256>this.fee.value
	frame_dig 2 // amountOfAlgos: uint64
	itob
	byte 0x666565 // "fee"
	app_global_get
	itob
	b*
	frame_bury 5 // denominator: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:182
	// feeUint256 = denominator / <uint256>SCALE
	frame_dig 5 // denominator: unsafe uint256
	byte 0x00000000000000000000000000000000000000000000000000005af3107a4000
	b/
	frame_bury 6 // feeUint256: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:184
	// fee = <uint64>feeUint256
	frame_dig 6 // feeUint256: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // fee: uint64

	// src/contracts/LimitOrders.algo.ts:186
	// this.transferTo(this.txn.sender, amountOfAlgos - fee)
	frame_dig 2 // amountOfAlgos: uint64
	frame_dig 7 // fee: uint64
	-
	txn Sender
	callsub transferTo

	// src/contracts/LimitOrders.algo.ts:187
	// this.feeAccumulated.value = this.feeAccumulated.value + fee
	byte 0x6665655f616363 // "fee_acc"
	dup
	app_global_get
	frame_dig 7 // fee: uint64
	+
	app_global_put

	// src/contracts/LimitOrders.algo.ts:189
	// this.FillOrder.log({
	// 			orderId: orderId,
	// 			maker: this.orderbook(orderId).value.maker,
	// 			taker: this.txn.sender,
	// 			filledAlgoAmount: amountOfAlgos,
	// 			filledArc200Amount: arc200Amount,
	// 			orderDirection: 0,
	// 			fee: <uint256>fee,
	// 		})
	byte 0x0db8f73c // FillOrder(uint64,address,address,uint64,uint256,uint8,uint256)
	frame_dig -1 // orderId: uint64
	itob
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	concat
	txn Sender
	concat
	frame_dig 2 // amountOfAlgos: uint64
	itob
	concat
	frame_dig -2 // arc200Amount: uint256
	concat
	byte 0x00
	concat
	frame_dig 7 // fee: uint64
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	concat
	log

	// if0_condition
	// src/contracts/LimitOrders.algo.ts:199
	// newAlgoAmount <= 1000
	frame_dig 4 // newAlgoAmount: uint64
	int 1000
	<=
	bz if0_else

	// if0_consequent
	// src/contracts/LimitOrders.algo.ts:200
	// this.orderbook(orderId).delete()
	frame_dig -1 // orderId: uint64
	itob
	box_del
	b if0_end

if0_else:
	// src/contracts/LimitOrders.algo.ts:202
	// this.orderbook(orderId).value = {
	// 				maker: boxSnap.maker,
	// 				arc200Id: boxSnap.arc200Id,
	// 				algoAmount: newAlgoAmount,
	// 				arc200Amount: newArc200Amount,
	// 				isBuyingAlgo: boxSnap.isBuyingAlgo,
	// 			}
	frame_dig -1 // orderId: uint64
	itob
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	int 32 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	concat
	frame_dig 4 // newAlgoAmount: uint64
	itob
	concat
	frame_dig 3 // newArc200Amount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	int 80 // headOffset
	int 1
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	extract 7 1
	concat
	box_put

if0_end:
	retsub

// fillArc200ToAlgoOrder(uint64,pay)void
abi_route_fillArc200ToAlgoOrder:
	// algoPayTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute fillArc200ToAlgoOrder(uint64,pay)void
	callsub fillArc200ToAlgoOrder
	int 1
	return

// fillArc200ToAlgoOrder(orderId: uint64, algoPayTxn: PayTxn): void
fillArc200ToAlgoOrder:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 9

	// src/contracts/LimitOrders.algo.ts:213
	// assert(this.orderbook(orderId).exists)
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop
	assert

	// src/contracts/LimitOrders.algo.ts:214
	// boxSnap = this.orderbook(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//boxSnap

	// src/contracts/LimitOrders.algo.ts:216
	// assert(boxSnap.isBuyingAlgo !== 0)
	int 80 // headOffset
	int 1
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	int 0
	!=
	assert

	// src/contracts/LimitOrders.algo.ts:218
	// verifyPayTxn(algoPayTxn, {
	// 			amount: { greaterThan: 0 },
	// 			sender: this.txn.sender,
	// 			receiver: this.app.address,
	// 		})
	// verify amount
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Amount
	int 0
	>
	assert

	// verify sender
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify receiver
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// src/contracts/LimitOrders.algo.ts:224
	// denominator = <uint256>algoPayTxn.amount * <uint256>this.fee.value
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Amount
	itob
	byte 0x666565 // "fee"
	app_global_get
	itob
	b*
	frame_bury 1 // denominator: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:225
	// feeUint256 = denominator / <uint256>SCALE
	frame_dig 1 // denominator: unsafe uint256
	byte 0x00000000000000000000000000000000000000000000000000005af3107a4000
	b/
	frame_bury 2 // feeUint256: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:228
	// fee = <uint64>feeUint256
	frame_dig 2 // feeUint256: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 3 // fee: uint64

	// src/contracts/LimitOrders.algo.ts:231
	// algoOutAmount = algoPayTxn.amount - fee
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Amount
	frame_dig 3 // fee: uint64
	-
	frame_bury 4 // algoOutAmount: uint64

	// src/contracts/LimitOrders.algo.ts:233
	// this.transferTo(boxSnap.maker, algoOutAmount)
	frame_dig 4 // algoOutAmount: uint64
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	callsub transferTo

	// src/contracts/LimitOrders.algo.ts:234
	// this.feeAccumulated.value = this.feeAccumulated.value + fee
	byte 0x6665655f616363 // "fee_acc"
	dup
	app_global_get
	frame_dig 3 // fee: uint64
	+
	app_global_put

	// src/contracts/LimitOrders.algo.ts:237
	// algoOutAmountUint256 = <uint256>algoOutAmount
	frame_dig 4 // algoOutAmount: uint64
	itob
	frame_bury 5 // algoOutAmountUint256: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:238
	// boxAlgoAmountUint256 = <uint256>boxSnap.algoAmount
	int 40 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	frame_bury 6 // boxAlgoAmountUint256: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:239
	// arc200OutAmount = (algoOutAmountUint256 * boxSnap.arc200Amount) / boxAlgoAmountUint256
	frame_dig 5 // algoOutAmountUint256: unsafe uint256
	int 48 // headOffset
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	b*
	frame_dig 6 // boxAlgoAmountUint256: unsafe uint256
	b/
	frame_bury 7 // arc200OutAmount: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:241
	// this.arc200TransferTo(boxSnap.arc200Id, this.txn.sender, <uint256>arc200OutAmount)
	frame_dig 7 // arc200OutAmount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	txn Sender
	int 32 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	callsub arc200TransferTo

	// src/contracts/LimitOrders.algo.ts:243
	// newArc200Amount = boxSnap.arc200Amount - arc200OutAmount
	int 48 // headOffset
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	frame_dig 7 // arc200OutAmount: unsafe uint256
	b-
	frame_bury 8 // newArc200Amount: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:244
	// newAlgoAmount = boxSnap.algoAmount - algoOutAmount
	int 40 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	frame_dig 4 // algoOutAmount: uint64
	-
	frame_bury 9 // newAlgoAmount: uint64

	// src/contracts/LimitOrders.algo.ts:246
	// this.FillOrder.log({
	// 			orderId: orderId,
	// 			maker: this.orderbook(orderId).value.maker,
	// 			taker: this.txn.sender,
	// 			filledAlgoAmount: algoOutAmount,
	// 			filledArc200Amount: arc200OutAmount,
	// 			orderDirection: 1,
	// 			fee: <uint256>fee,
	// 		})
	byte 0x0db8f73c // FillOrder(uint64,address,address,uint64,uint256,uint8,uint256)
	frame_dig -1 // orderId: uint64
	itob
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	concat
	txn Sender
	concat
	frame_dig 4 // algoOutAmount: uint64
	itob
	concat
	frame_dig 7 // arc200OutAmount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	byte 0x01
	concat
	frame_dig 3 // fee: uint64
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	concat
	log

	// if1_condition
	// src/contracts/LimitOrders.algo.ts:256
	// newAlgoAmount <= 1000
	frame_dig 9 // newAlgoAmount: uint64
	int 1000
	<=
	bz if1_else

	// if1_consequent
	// src/contracts/LimitOrders.algo.ts:257
	// this.orderbook(orderId).delete()
	frame_dig -1 // orderId: uint64
	itob
	box_del
	b if1_end

if1_else:
	// src/contracts/LimitOrders.algo.ts:259
	// this.orderbook(orderId).value = {
	// 				maker: boxSnap.maker,
	// 				arc200Id: boxSnap.arc200Id,
	// 				algoAmount: newAlgoAmount,
	// 				arc200Amount: newArc200Amount,
	// 				isBuyingAlgo: boxSnap.isBuyingAlgo,
	// 			}
	frame_dig -1 // orderId: uint64
	itob
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	int 32 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	concat
	frame_dig 9 // newAlgoAmount: uint64
	itob
	concat
	frame_dig 8 // newArc200Amount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	int 80 // headOffset
	int 1
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	extract 7 1
	concat
	box_put

if1_end:
	retsub

// cancelOrder(uint64)void
abi_route_cancelOrder:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute cancelOrder(uint64)void
	callsub cancelOrder
	int 1
	return

// cancelOrder(orderId: uint64): void
cancelOrder:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/contracts/LimitOrders.algo.ts:270
	// assert(this.orderbook(orderId).exists)
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop
	assert

	// src/contracts/LimitOrders.algo.ts:271
	// boxSnap = this.orderbook(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//boxSnap

	// src/contracts/LimitOrders.algo.ts:272
	// assert(boxSnap.maker === this.txn.sender)
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	txn Sender
	==
	assert

	// if2_condition
	// src/contracts/LimitOrders.algo.ts:274
	// boxSnap.isBuyingAlgo === 0
	int 80 // headOffset
	int 1
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	int 0
	==
	bz if2_else

	// if2_consequent
	// src/contracts/LimitOrders.algo.ts:275
	// this.transferTo(boxSnap.maker, boxSnap.algoAmount)
	int 40 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	callsub transferTo

	// src/contracts/LimitOrders.algo.ts:276
	// this.CancelOrder.log({
	// 				maker: boxSnap.maker,
	// 				orderId: orderId,
	// 				returnedAmount: <uint256>boxSnap.algoAmount,
	// 				orderDirection: boxSnap.isBuyingAlgo,
	// 			})
	byte 0x29d99bd0 // CancelOrder(uint64,address,uint256,uint8)
	frame_dig -1 // orderId: uint64
	itob
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	concat
	int 40 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	int 80 // headOffset
	int 1
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	extract 7 1
	concat
	concat
	log
	b if2_end

if2_else:
	// src/contracts/LimitOrders.algo.ts:283
	// this.arc200TransferTo(boxSnap.arc200Id, boxSnap.maker, boxSnap.arc200Amount)
	int 48 // headOffset
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	int 32 // headOffset
	int 8
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	callsub arc200TransferTo

	// src/contracts/LimitOrders.algo.ts:284
	// this.CancelOrder.log({
	// 				maker: boxSnap.maker,
	// 				orderId: orderId,
	// 				returnedAmount: boxSnap.arc200Amount,
	// 				orderDirection: boxSnap.isBuyingAlgo,
	// 			})
	byte 0x29d99bd0 // CancelOrder(uint64,address,uint256,uint8)
	frame_dig -1 // orderId: uint64
	itob
	int 0
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	concat
	int 48 // headOffset
	int 32
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	concat
	int 80 // headOffset
	int 1
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	extract 7 1
	concat
	concat
	log

if2_end:
	// src/contracts/LimitOrders.algo.ts:292
	// this.orderbook(orderId).delete()
	frame_dig -1 // orderId: uint64
	itob
	box_del
	retsub

// registerOnline(byte[],byte[],byte[],uint64,uint64,uint64)void
abi_route_registerOnline:
	// vote_key_dilution: uint64
	txna ApplicationArgs 6
	btoi

	// vote_last: uint64
	txna ApplicationArgs 5
	btoi

	// vote_first: uint64
	txna ApplicationArgs 4
	btoi

	// vote_pk: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// state_proof_pk: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// selection_pk: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute registerOnline(byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub registerOnline
	int 1
	return

// registerOnline(selection_pk: bytes, state_proof_pk: bytes, vote_pk: bytes, vote_first: uint64, vote_last: uint64, vote_key_dilution: uint64): void
registerOnline:
	proto 6 0

	// src/contracts/LimitOrders.algo.ts:303
	// assert(this.txn.sender === this.owner.value)
	txn Sender
	byte 0x6f776e6572 // "owner"
	app_global_get
	==
	assert

	// src/contracts/LimitOrders.algo.ts:305
	// sendOnlineKeyRegistration({
	// 			sender: this.app.address,
	// 			selectionPK: selection_pk,
	// 			stateProofPK: state_proof_pk,
	// 			votePK: vote_pk,
	// 			voteFirst: vote_first,
	// 			voteLast: vote_last,
	// 			voteKeyDilution: vote_key_dilution,
	// 			fee: 1000,
	// 		})
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// src/contracts/LimitOrders.algo.ts:306
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:307
	// selectionPK: selection_pk
	frame_dig -1 // selection_pk: bytes
	itxn_field SelectionPK

	// src/contracts/LimitOrders.algo.ts:308
	// stateProofPK: state_proof_pk
	frame_dig -2 // state_proof_pk: bytes
	itxn_field StateProofPK

	// src/contracts/LimitOrders.algo.ts:309
	// votePK: vote_pk
	frame_dig -3 // vote_pk: bytes
	itxn_field VotePK

	// src/contracts/LimitOrders.algo.ts:310
	// voteFirst: vote_first
	frame_dig -4 // vote_first: uint64
	itxn_field VoteFirst

	// src/contracts/LimitOrders.algo.ts:311
	// voteLast: vote_last
	frame_dig -5 // vote_last: uint64
	itxn_field VoteLast

	// src/contracts/LimitOrders.algo.ts:312
	// voteKeyDilution: vote_key_dilution
	frame_dig -6 // vote_key_dilution: uint64
	itxn_field VoteKeyDilution

	// src/contracts/LimitOrders.algo.ts:313
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// registerOffline()void
abi_route_registerOffline:
	// execute registerOffline()void
	callsub registerOffline
	int 1
	return

// registerOffline(): void
registerOffline:
	proto 0 0

	// src/contracts/LimitOrders.algo.ts:318
	// assert(this.txn.sender === this.owner.value)
	txn Sender
	byte 0x6f776e6572 // "owner"
	app_global_get
	==
	assert

	// src/contracts/LimitOrders.algo.ts:320
	// sendOfflineKeyRegistration({
	// 			sender: this.app.address,
	// 			fee: 1000,
	// 		})
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// src/contracts/LimitOrders.algo.ts:321
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:322
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

create_NoOp:
	method "createApplication(address,uint64)void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "setFee(uint64)void"
	method "setOwner(address)void"
	method "collectFee(uint64)void"
	method "createAlgoSellOrder(pay,application,uint256)void"
	method "createAlgoBuyOrder(application,uint256,uint64)void"
	method "fillAlgoToArc200Order(uint64,uint256)void"
	method "fillArc200ToAlgoOrder(uint64,pay)void"
	method "cancelOrder(uint64)void"
	method "registerOnline(byte[],byte[],byte[],uint64,uint64,uint64)void"
	method "registerOffline()void"
	txna ApplicationArgs 0
	match abi_route_setFee abi_route_setOwner abi_route_collectFee abi_route_createAlgoSellOrder abi_route_createAlgoBuyOrder abi_route_fillAlgoToArc200Order abi_route_fillArc200ToAlgoOrder abi_route_cancelOrder abi_route_registerOnline abi_route_registerOffline
	err

call_UpdateApplication:
	method "updateApplication()void"
	txna ApplicationArgs 0
	match abi_route_updateApplication
	err